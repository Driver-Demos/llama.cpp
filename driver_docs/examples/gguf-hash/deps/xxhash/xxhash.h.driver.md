# Purpose
The provided code is a comprehensive header file for the xxHash library, which implements a highly efficient non-cryptographic hash algorithm, including versions like XXH32, XXH64, and the advanced XXH3 with 64-bit and 128-bit outputs. Its primary purpose is to define the API and offer implementations for these algorithms, catering to projects that demand rapid hashing, especially for large datasets or high-performance applications. The code supports both single-shot and streaming APIs, allowing for flexible hashing of contiguous memory blocks or incremental data streams, making it versatile for various use cases such as data integrity checks and hash tables. It includes detailed documentation, usage examples, and optimizations for different architectures like SSE2, AVX2, and NEON, ensuring optimal performance across platforms. Additionally, the library provides customization options with custom secrets and seeds, enhancing security and adaptability, and is designed for easy integration into other projects through its public APIs and external interfaces.
# Imports and Dependencies

---
- `stddef.h`
- `inttypes.h`
- `stdint.h`
- `limits.h`
- `stdalign.h`
- `stdlib.h`
- `string.h`
- `assert.h`
- `arm_sve.h`
- `arm_neon.h`
- `immintrin.h`
- `emmintrin.h`
- `intrin.h`
- `s390intrin.h`
- `altivec.h`
- `mmintrin.h`


# Data Structures

---
### XXH\_errorcode
- **Type**: `enum`
- **Members**:
    - `XXH_OK`: Represents a successful operation with no errors.
    - `XXH_ERROR`: Indicates that an error has occurred.
- **Description**: The `XXH_errorcode` is an enumeration that defines error codes for operations, with `XXH_OK` indicating success and `XXH_ERROR` indicating a failure or error condition. This enum is typically used to standardize the return values of functions, allowing them to communicate success or failure in a consistent manner.


---
### XXH32\_state\_t
- **Type**: `typedef struct`
- **Members**:
    - `XXH32_state_s`: The underlying structure for the XXH32_state_t type, details of which are not provided in this snippet.
- **Description**: The `XXH32_state_t` is a typedef for a structure named `XXH32_state_s`, which is likely used to maintain the state of the XXH32 hashing algorithm. The actual fields and details of the structure are not provided in the given code snippet, indicating that the structure's definition is likely elsewhere in the codebase. This type is typically used to store intermediate states of the hash computation, allowing for incremental hashing.


---
### XXH32\_canonical\_t
- **Type**: `struct`
- **Members**:
    - `digest`: An array of 4 unsigned char representing the hash bytes in big endian format.
- **Description**: The `XXH32_canonical_t` structure is used to store a 32-bit hash value in a canonical form, specifically in big endian byte order. This is useful for ensuring consistent hash representation across different platforms, which may have varying native endianness. The structure contains a single member, `digest`, which is an array of 4 bytes that holds the hash value.


---
### XXH64\_state\_t
- **Type**: `typedef struct`
- **Members**:
    - `XXH64_state_s`: An incomplete type used to define the XXH64_state_t type.
- **Description**: The `XXH64_state_t` is a typedef for an incomplete struct type `XXH64_state_s`. This suggests that `XXH64_state_t` is intended to be used as a handle or pointer to a more complex data structure that is defined elsewhere. It is commonly used in hashing algorithms to maintain state information across multiple function calls, allowing for incremental hashing.


---
### XXH64\_canonical\_t
- **Type**: `struct`
- **Members**:
    - `digest`: An array of unsigned char that stores the canonical representation of the hash value.
- **Description**: The `XXH64_canonical_t` structure is used to store the canonical form of a 64-bit hash value generated by the XXH64 hashing algorithm. It contains a single member, `digest`, which is an array of unsigned characters sized to match the hash value. This structure is typically used for storing and transferring hash values in a consistent and portable format.


---
### XXH3\_state\_t
- **Type**: `typedef struct`
- **Members**:
    - `XXH3_state_s`: The underlying structure for the XXH3_state_t type, which is not defined in the provided code.
- **Description**: The `XXH3_state_t` is a typedef for a structure named `XXH3_state_s`, which is part of the XXH3 hashing algorithm's state management. The actual definition of `XXH3_state_s` is not provided in the code snippet, indicating that it is likely defined elsewhere in the library. This structure is used to maintain the state of the XXH3 hashing process, allowing for incremental hashing operations. The function `XXH3_createState` is a public API function that allocates and initializes a new instance of this state structure, returning a pointer to it.


---
### XXH128\_hash\_t
- **Type**: `struct`
- **Members**:
    - `low64`: Represents the lower 64 bits of the 128-bit hash value.
    - `high64`: Represents the higher 64 bits of the 128-bit hash value.
- **Description**: The `XXH128_hash_t` structure is designed to store a 128-bit hash value, which is split into two 64-bit components. The `low64` member holds the lower half of the hash, while the `high64` member holds the upper half. This structure is typically used in hashing algorithms that require a 128-bit hash output, providing a way to handle large hash values efficiently by breaking them into two manageable parts.


---
### XXH128\_canonical\_t
- **Type**: `struct`
- **Members**:
    - `digest`: An array of unsigned char that stores the canonical representation of the XXH128 hash.
- **Description**: The `XXH128_canonical_t` structure is used to store the canonical form of an XXH128 hash, which is a fixed-size array of unsigned characters. This structure is typically used for serialization or storage purposes, ensuring that the hash is represented in a consistent and portable format across different platforms.


---
### XXH32\_state\_s
- **Type**: `struct`
- **Members**:
    - `total_len_32`: Total length hashed, modulo 2^32.
    - `large_len`: Indicates if the hash is greater than or equal to 16, handling overflow of total_len_32.
    - `v`: Array of four accumulator lanes.
    - `mem32`: Internal buffer for partial reads, treated as an array of unsigned char[16].
    - `memsize`: Amount of data currently in mem32.
    - `reserved`: Reserved field that should not be read or written to.
- **Description**: The `XXH32_state_s` structure is used in the XXH32 hashing algorithm to maintain the state of the hash computation. It includes fields for tracking the total length of data hashed, handling potential overflow, and storing intermediate hash values. The structure also contains an internal buffer for managing partial data reads and a reserved field for future use or alignment purposes. This structure is essential for the incremental hashing process, allowing the hash to be computed in chunks rather than requiring all data to be available at once.


---
### XXH64\_state\_s
- **Type**: `struct`
- **Members**:
    - `total_len`: Total length hashed, always 64-bit.
    - `v`: Array of four 64-bit hash values used as accumulator lanes.
    - `mem64`: Internal buffer for partial reads, treated as an array of 32 unsigned chars.
    - `memsize`: Amount of data currently stored in the mem64 buffer.
    - `reserved32`: Reserved field for padding purposes.
    - `reserved64`: Reserved field that should not be read or written to.
- **Description**: The `XXH64_state_s` structure is used in the XXH64 hashing algorithm to maintain the state of the hash computation. It includes fields for tracking the total length of data hashed, accumulator lanes for intermediate hash values, and a buffer for handling partial reads. Additionally, it contains reserved fields for padding and future use, ensuring proper memory alignment and structure size.


---
### XXH3\_state\_s
- **Type**: `struct`
- **Members**:
    - `acc`: The 8 accumulators used in the hashing process.
    - `customSecret`: Stores a custom secret generated from a seed.
    - `buffer`: The internal buffer for temporary data storage.
    - `bufferedSize`: The amount of memory currently in the buffer.
    - `useSeed`: Reserved field for padding on 64-bit systems.
    - `nbStripesSoFar`: Tracks the number of stripes processed.
    - `totalLen`: Total length of data hashed, always 64-bit.
    - `nbStripesPerBlock`: Number of stripes processed per block.
    - `secretLimit`: Size of the custom or external secret.
    - `seed`: Seed value for hash variants using a seed.
    - `reserved64`: Reserved field for future use.
    - `extSecret`: Pointer to an external secret for specific hash variants.
- **Description**: The `XXH3_state_s` structure is a complex data structure used in the XXH3 hashing algorithm to maintain the state of the hash computation. It includes accumulators, buffers, and secret management fields to handle the hashing process efficiently. The structure is designed to support both seeded and secret-based hashing variants, with fields for managing internal and external secrets, as well as tracking the progress of the hashing operation through stripe and length counters. The structure is aligned for optimal performance on 64-bit systems, with reserved fields for future extensions or padding.


---
### unalign
- **Type**: `union`
- **Members**:
    - `u32`: A 32-bit unsigned integer field within the union.
- **Description**: The 'unalign' data structure is a union that contains a single member, 'u32', which is a 32-bit unsigned integer. It is defined with the '__attribute__((__packed__))' attribute, indicating that the compiler should not add any padding between the members of the union, ensuring that the data is tightly packed. This is particularly useful in scenarios where memory alignment is critical, such as in low-level programming or when interfacing with hardware.


---
### XXH\_alignment
- **Type**: `enum`
- **Members**:
    - `XXH_aligned`: Indicates that the data is aligned.
    - `XXH_unaligned`: Indicates that the data may be unaligned.
- **Description**: The `XXH_alignment` enumeration defines two possible states for data alignment: `XXH_aligned`, which signifies that the data is properly aligned, and `XXH_unaligned`, which suggests that the data might not be aligned. This enumeration is likely used to optimize or handle data processing based on its alignment status.


---
### unalign64
- **Type**: `union`
- **Members**:
    - `u32`: A 32-bit unsigned integer member of the union.
    - `u64`: A 64-bit unsigned integer member of the union.
- **Description**: The `unalign64` is a packed union data structure that allows access to the same memory location as either a 32-bit or a 64-bit unsigned integer. This is useful for handling data that may be misaligned in memory, ensuring that the data can be accessed correctly regardless of its alignment. The `__attribute__((__packed__))` ensures that the compiler does not add any padding between the members, which is crucial for certain low-level operations where precise control over memory layout is required.


---
### XXH\_VECTOR\_TYPE
- **Type**: `enum`
- **Members**:
    - `XXH_SCALAR`: Portable scalar version.
    - `XXH_SSE2`: SSE2 for Pentium 4, Opteron, all x86_64, and guaranteed on Windows 10, macOS, and Android x86.
    - `XXH_AVX2`: AVX2 for Haswell and Bulldozer.
    - `XXH_AVX512`: AVX512 for Skylake and Icelake.
    - `XXH_NEON`: NEON for most ARMv7-A, all AArch64, and WASM SIMD128 via the SIMDeverywhere polyfill.
    - `XXH_VSX`: VSX and ZVector for POWER8/z13 (64-bit).
    - `XXH_SVE`: SVE for some ARMv8-A and ARMv9-A.
- **Description**: The `XXH_VECTOR_TYPE` is an enumeration that defines various vectorization strategies for different CPU architectures and instruction sets. It includes options for scalar processing, as well as SIMD (Single Instruction, Multiple Data) extensions like SSE2, AVX2, AVX512, NEON, VSX, and SVE, each tailored for specific hardware capabilities to optimize performance.


# Functions

---
### XXH\_malloc<!-- {{#callable:XXH_malloc}} -->
Allocates memory of a specified size using `malloc`.
- **Inputs**:
    - `s`: The size in bytes of the memory block to allocate.
- **Control Flow**:
    - Calls the `malloc` function with the size `s` to allocate the requested memory.
    - Returns the pointer to the allocated memory block, or NULL if the allocation fails.
- **Output**: A pointer to the allocated memory block of size `s`, or NULL if the allocation fails.


---
### XXH\_free<!-- {{#callable:XXH_free}} -->
The `XXH_free` function deallocates memory previously allocated with `malloc`, `calloc`, or `realloc`.
- **Inputs**:
    - `p`: A pointer to the memory block that needs to be freed.
- **Control Flow**:
    - The function takes a single pointer argument `p`.
    - It calls the standard library function `free` to deallocate the memory pointed to by `p`.
- **Output**: The function does not return a value; it simply frees the allocated memory.


---
### XXH\_memcpy<!-- {{#callable:XXH_memcpy}} -->
Copies a specified number of bytes from a source memory location to a destination memory location.
- **Inputs**:
    - `dest`: A pointer to the destination memory location where the data will be copied to.
    - `src`: A pointer to the source memory location from which the data will be copied.
    - `size`: The number of bytes to copy from the source to the destination.
- **Control Flow**:
    - Calls the standard library function `memcpy` to perform the memory copy operation.
    - Returns the pointer to the destination memory location after the copy is complete.
- **Output**: Returns a pointer to the destination memory location (`dest`) after copying the specified number of bytes.


---
### XXH\_read32<!-- {{#callable:XXH_read32}} -->
Reads a 32-bit unsigned integer from a specified memory location.
- **Inputs**:
    - `memPtr`: A pointer to the memory location from which the 32-bit value will be read.
- **Control Flow**:
    - The function declares a variable `val` of type `xxh_u32` to hold the value read from memory.
    - It uses the [`XXH_memcpy`](#XXH_memcpy) function to copy the data from the memory location pointed to by `memPtr` into the `val` variable.
    - Finally, it returns the value stored in `val`.
- **Output**: Returns the 32-bit unsigned integer read from the specified memory location.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH\_isLittleEndian<!-- {{#callable:XXH_isLittleEndian}} -->
Determines if the system architecture is little-endian.
- **Inputs**: None
- **Control Flow**:
    - A union is defined to hold a 32-bit integer and its corresponding byte representation.
    - The union is initialized with the value 1, allowing access to its individual bytes.
    - The function returns the first byte of the union, which indicates endianness: if it is 1, the system is little-endian.
- **Output**: Returns 1 if the system is little-endian, otherwise returns 0.


---
### XXH\_swap32<!-- {{#callable:XXH_swap32}} -->
The `XXH_swap32` function swaps the byte order of a 32-bit unsigned integer.
- **Inputs**:
    - `x`: A 32-bit unsigned integer whose byte order is to be swapped.
- **Control Flow**:
    - The function takes the input `x` and shifts its bits to rearrange the byte order.
    - It uses bitwise AND operations with masks to isolate each byte after shifting.
    - The results of the shifts and masks are combined using the bitwise OR operator to form the final swapped value.
- **Output**: The function returns a 32-bit unsigned integer with its byte order swapped.


---
### XXH\_readLE32<!-- {{#callable:XXH_readLE32}} -->
Reads a 32-bit little-endian integer from a pointer, accounting for the CPU's endianness.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which the 32-bit integer is to be read.
- **Control Flow**:
    - Checks if the CPU is little-endian using the `XXH_CPU_LITTLE_ENDIAN` macro.
    - If the CPU is little-endian, it directly reads the 32-bit integer using [`XXH_read32`](#XXH_read32).
    - If the CPU is not little-endian, it reads the 32-bit integer and swaps its byte order using [`XXH_swap32`](#XXH_swap32).
- **Output**: Returns a 32-bit unsigned integer read from the specified memory location, correctly adjusted for the system's endianness.
- **Functions called**:
    - [`XXH_read32`](#XXH_read32)
    - [`XXH_swap32`](#XXH_swap32)


---
### XXH\_readBE32<!-- {{#callable:XXH_readBE32}} -->
Reads a 32-bit big-endian integer from a pointer, swapping bytes if the CPU is little-endian.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which the 32-bit integer is to be read.
- **Control Flow**:
    - Checks if the CPU is little-endian using the `XXH_CPU_LITTLE_ENDIAN` macro.
    - If the CPU is little-endian, it reads the 32-bit integer using [`XXH_read32`](#XXH_read32) and swaps the byte order with [`XXH_swap32`](#XXH_swap32).
    - If the CPU is not little-endian, it directly reads the 32-bit integer using [`XXH_read32`](#XXH_read32) without swapping.
- **Output**: Returns a 32-bit unsigned integer read from the specified memory location, correctly handling endianness.
- **Functions called**:
    - [`XXH_swap32`](#XXH_swap32)
    - [`XXH_read32`](#XXH_read32)


---
### XXH\_readLE32\_align<!-- {{#callable:XXH_readLE32_align}} -->
Reads a 32-bit little-endian integer from a pointer with alignment consideration.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which the 32-bit integer is to be read.
    - `align`: An enumeration value indicating whether the read operation is aligned or unaligned.
- **Control Flow**:
    - Checks if the `align` parameter is set to `XXH_unaligned`.
    - If `align` is `XXH_unaligned`, it calls the [`XXH_readLE32`](#XXH_readLE32) function to read the value.
    - If `align` is not `XXH_unaligned`, it checks if the system is little-endian.
    - If the system is little-endian, it directly dereferences the pointer to read the value.
    - If the system is not little-endian, it reads the value and swaps the byte order using [`XXH_swap32`](#XXH_swap32).
- **Output**: Returns the 32-bit integer read from the specified memory location, either directly or after byte-swapping, depending on the alignment and endianness.
- **Functions called**:
    - [`XXH_readLE32`](#XXH_readLE32)
    - [`XXH_swap32`](#XXH_swap32)


---
### XXH\_versionNumber<!-- {{#callable:XXH_versionNumber}} -->
Returns the version number of the XXH library.
- **Inputs**: None
- **Control Flow**:
    - The function does not take any input arguments.
    - It directly returns the value of `XXH_VERSION_NUMBER`.
- **Output**: The output is an unsigned integer representing the version number of the XXH library.


---
### XXH32\_round<!-- {{#callable:XXH32_round}} -->
The `XXH32_round` function performs a single round of the XXH32 hash algorithm by updating an accumulator with a given input value.
- **Inputs**:
    - `acc`: The current accumulator value, which is updated during the hashing process.
    - `input`: The input value to be processed and incorporated into the hash calculation.
- **Control Flow**:
    - The function first updates the accumulator by adding the product of the input and a constant `XXH_PRIME32_2`.
    - It then rotates the updated accumulator left by 13 bits using the `XXH_rotl32` function.
    - Next, the accumulator is multiplied by another constant `XXH_PRIME32_1`.
    - If specific compiler optimizations are enabled (SSE4.1, AArch64, or WASM SIMD128), a compiler fence is applied to prevent autovectorization of the loop, ensuring that the function executes as intended without performance degradation.
- **Output**: The function returns the updated accumulator value after processing the input.


---
### XXH32\_avalanche<!-- {{#callable:XXH32_avalanche}} -->
The `XXH32_avalanche` function applies a series of bitwise operations and multiplications to a hash value to produce a final hash result.
- **Inputs**:
    - `hash`: An unsigned 32-bit integer representing the initial hash value to be processed.
- **Control Flow**:
    - The function begins by performing a bitwise XOR operation on `hash` with itself right-shifted by 15 bits.
    - Next, the modified `hash` is multiplied by a constant `XXH_PRIME32_2`.
    - The function then applies another XOR operation on `hash` with itself right-shifted by 13 bits.
    - This is followed by multiplying the `hash` by another constant `XXH_PRIME32_3`.
    - Finally, a third XOR operation is performed on `hash` with itself right-shifted by 16 bits before returning the final value.
- **Output**: The function returns the final processed hash value as an unsigned 32-bit integer.


---
### XXH32\_finalize<!-- {{#callable:XXH32_finalize}} -->
Finalizes the XXH32 hash computation by processing the remaining bytes and returning the final hash value.
- **Inputs**:
    - `hash`: The current hash value computed so far, of type `xxh_u32`.
    - `ptr`: A pointer to the byte array that contains the data to be processed, of type `const xxh_u8*`.
    - `len`: The length of the data to be processed, of type `size_t`.
    - `align`: An alignment parameter of type `XXH_alignment`, though it is not used in the function body.
- **Control Flow**:
    - Checks if `ptr` is NULL and asserts that `len` must be 0 in that case.
    - If `XXH32_ENDJMP` is false, processes the data in chunks of 4 bytes using `XXH_PROCESS4` until less than 4 bytes remain, then processes any remaining bytes using `XXH_PROCESS1`.
    - If `XXH32_ENDJMP` is true, uses a switch statement to handle the remaining bytes based on the value of `len & 15`, processing them accordingly with `XXH_PROCESS4` and `XXH_PROCESS1`.
    - Each processing macro updates the hash and rotates it, applying specific prime multipliers.
    - Finally, the function calls [`XXH32_avalanche`](#XXH32_avalanche) to finalize the hash and return the result.
- **Output**: Returns the final computed hash value of type `xxh_u32` after processing the input data.
- **Functions called**:
    - [`XXH32_avalanche`](#XXH32_avalanche)


---
### XXH32\_endian\_align<!-- {{#callable:XXH32_endian_align}} -->
Calculates a 32-bit hash value for the given input data with optional alignment and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, represented as an array of `xxh_u8`.
    - `len`: The length of the input data in bytes.
    - `seed`: A 32-bit unsigned integer used to initialize the hash calculation.
    - `align`: An enumeration value that specifies the alignment of the input data.
- **Control Flow**:
    - Checks if the input pointer is NULL; if so, asserts that the length is zero.
    - If the length of the input is 16 bytes or more, initializes four hash variables and processes the input in chunks of 4 bytes using the [`XXH32_round`](#XXH32_round) function.
    - Continues processing until the input pointer reaches the limit, which is 15 bytes before the end of the input.
    - If the length is less than 16 bytes, initializes the hash value with the seed and a prime constant.
    - Adds the length of the input to the hash value.
    - Finalizes the hash value using the [`XXH32_finalize`](#XXH32_finalize) function, which incorporates any remaining bytes and the specified alignment.
- **Output**: Returns a 32-bit unsigned integer representing the computed hash value.
- **Functions called**:
    - [`XXH32_round`](#XXH32_round)
    - [`XXH32_finalize`](#XXH32_finalize)


---
### XXH32\_hash\_t<!-- {{#callable:XXH32_hash_t}} -->
Calculates the 32-bit hash of the input data using a specified seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed`: A 32-bit hash seed used to initialize the hash computation.
- **Control Flow**:
    - Checks if the `XXH_NO_STREAM` is not defined and if `XXH_SIZE_OPT` is greater than or equal to 2.
    - If the conditions are met, initializes a `XXH32_state_t` state and resets it with the provided seed.
    - Updates the state with the input data and its length.
    - Returns the final digest of the hash from the state.
    - If the conditions are not met, checks if the input is 4-byte aligned.
    - If aligned, calls [`XXH32_endian_align`](#XXH32_endian_align) with aligned parameters; otherwise, calls it with unaligned parameters.
- **Output**: Returns a 32-bit hash value computed from the input data.
- **Functions called**:
    - [`XXH_errorcode::XXH32_reset`](#XXH_errorcodeXXH32_reset)
    - [`XXH_errorcode::XXH32_update`](#XXH_errorcodeXXH32_update)
    - [`XXH32_hash_t::XXH32_digest`](#XXH32_hash_tXXH32_digest)
    - [`XXH32_endian_align`](#XXH32_endian_align)


---
### XXH32\_freeState<!-- {{#callable:XXH_errorcode::XXH32_freeState}} -->
Frees the memory allocated for a `XXH32_state_t` structure.
- **Inputs**:
    - `statePtr`: A pointer to the `XXH32_state_t` structure that needs to be freed.
- **Control Flow**:
    - Calls the [`XXH_free`](#XXH_free) function to deallocate the memory pointed to by `statePtr`.
    - Returns `XXH_OK` to indicate successful completion of the operation.
- **Output**: Returns an `XXH_errorcode` indicating the result of the operation, which is `XXH_OK` for successful memory deallocation.
- **Functions called**:
    - [`XXH_free`](#XXH_free)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH32\_copyState<!-- {{#callable:XXH32_copyState}} -->
Copies the state from one `XXH32_state_t` structure to another.
- **Inputs**:
    - `dstState`: A pointer to the destination `XXH32_state_t` structure where the state will be copied.
    - `srcState`: A pointer to the source `XXH32_state_t` structure from which the state will be copied.
- **Control Flow**:
    - The function uses [`XXH_memcpy`](#XXH_memcpy) to copy the memory from `srcState` to `dstState`.
    - The size of the memory to copy is determined by `sizeof(*dstState)`, ensuring that the entire state structure is copied.
- **Output**: The function does not return a value; it modifies the `dstState` in place.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH32\_reset<!-- {{#callable:XXH_errorcode::XXH32_reset}} -->
Resets the state of a `XXH32` hash computation with a given seed.
- **Inputs**:
    - `statePtr`: A pointer to a `XXH32_state_t` structure that holds the state of the hash computation.
    - `seed`: A `XXH32_hash_t` value used to initialize the hash state.
- **Control Flow**:
    - Checks if `statePtr` is not NULL using `XXH_ASSERT` to ensure valid input.
    - Clears the memory of the state structure pointed to by `statePtr` using `memset` to initialize it to zero.
    - Sets the first four values of the state structure's vector `v` based on the provided `seed` and predefined constants `XXH_PRIME32_1` and `XXH_PRIME32_2`.
    - Returns `XXH_OK` to indicate successful completion of the reset operation.
- **Output**: Returns an `XXH_errorcode` indicating the success of the operation, specifically `XXH_OK`.
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH32\_update<!-- {{#callable:XXH_errorcode::XXH32_update}} -->
Updates the state of a 32-bit hash computation with new input data.
- **Inputs**:
    - `state`: A pointer to an `XXH32_state_t` structure that holds the current state of the hash computation.
    - `input`: A pointer to the input data to be added to the hash computation.
    - `len`: The length of the input data in bytes.
- **Control Flow**:
    - Checks if the input pointer is NULL; if so, asserts that length is zero and returns success.
    - Calculates the new total length of the data processed and updates the state to indicate if the length is large.
    - If the combined size of the current memory and new input is less than 16 bytes, it copies the input into the temporary buffer and returns.
    - If there is leftover data in the temporary buffer, it processes this data by filling the buffer and updating the hash state.
    - Processes the input data in chunks of 16 bytes, updating the hash state for each chunk.
    - If there are remaining bytes after processing full chunks, it copies them into the temporary buffer for future updates.
- **Output**: Returns `XXH_OK` to indicate successful update of the hash state.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)
    - [`XXH32_round`](#XXH32_round)
    - [`XXH_readLE32`](#XXH_readLE32)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH32\_digest<!-- {{#callable:XXH32_hash_t::XXH32_digest}} -->
Calculates the final 32-bit hash value from the given `XXH32_state_t` structure.
- **Inputs**:
    - `state`: A pointer to an `XXH32_state_t` structure that contains the current state of the hash computation, including intermediate values and lengths.
- **Control Flow**:
    - Checks if the `large_len` field in the `state` structure is set to determine the hashing method.
    - If `large_len` is true, it computes the hash by rotating and summing specific values from the `v` array in the `state` structure.
    - If `large_len` is false, it initializes the hash with the value of `v[2]` (the seed) and adds a constant `XXH_PRIME32_5`.
    - Adds the total length of the input data (`total_len_32`) to the computed hash value.
    - Calls the [`XXH32_finalize`](#XXH32_finalize) function to finalize the hash computation using the computed hash and the state memory.
- **Output**: Returns the final computed 32-bit hash value of type `XXH32_hash_t`.
- **Functions called**:
    - [`XXH32_finalize`](#XXH32_finalize)


---
### XXH32\_canonicalFromHash<!-- {{#callable:XXH32_canonicalFromHash}} -->
Converts a 32-bit hash value into its canonical form and stores it in a specified destination.
- **Inputs**:
    - `dst`: A pointer to a `XXH32_canonical_t` structure where the canonical form of the hash will be stored.
    - `hash`: A 32-bit hash value of type `XXH32_hash_t` that needs to be converted to its canonical form.
- **Control Flow**:
    - The function asserts that the size of `XXH32_canonical_t` is equal to the size of `XXH32_hash_t` to ensure compatibility.
    - If the CPU architecture is little-endian, the hash value is swapped to convert it to big-endian format.
    - The function then copies the (potentially swapped) hash value into the memory location pointed to by `dst`.
- **Output**: The function does not return a value; instead, it modifies the memory at the location pointed to by `dst` to contain the canonical representation of the provided hash.
- **Functions called**:
    - [`XXH_swap32`](#XXH_swap32)
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH32\_hashFromCanonical<!-- {{#callable:XXH32_hash_t::XXH32_hashFromCanonical}} -->
Calculates a 32-bit hash from a canonical representation using big-endian reading.
- **Inputs**:
    - `src`: A pointer to a `XXH32_canonical_t` structure that contains the data to be hashed.
- **Control Flow**:
    - The function directly calls [`XXH_readBE32`](#XXH_readBE32) with the provided `src` pointer.
    - The [`XXH_readBE32`](#XXH_readBE32) function reads a 32-bit value from the memory location pointed to by `src` in big-endian format.
- **Output**: Returns a `XXH32_hash_t` which is the computed 32-bit hash value derived from the input data.
- **Functions called**:
    - [`XXH_readBE32`](#XXH_readBE32)


---
### XXH\_read64<!-- {{#callable:XXH_read64}} -->
Reads a 64-bit unsigned integer from a specified memory location.
- **Inputs**:
    - `memPtr`: A pointer to the memory location from which the 64-bit value will be read.
- **Control Flow**:
    - The function declares a variable `val` of type `xxh_u64` to hold the value read from memory.
    - It uses the [`XXH_memcpy`](#XXH_memcpy) function to copy `sizeof(val)` bytes from the memory location pointed to by `memPtr` into `val`.
    - Finally, it returns the value stored in `val`.
- **Output**: Returns the 64-bit unsigned integer read from the specified memory location.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH\_swap64<!-- {{#callable:XXH_swap64}} -->
The `XXH_swap64` function swaps the byte order of a 64-bit unsigned integer.
- **Inputs**:
    - `x`: A 64-bit unsigned integer (`xxh_u64`) whose byte order is to be swapped.
- **Control Flow**:
    - The function takes the input `x` and shifts its bits to the left and right to isolate each byte.
    - Each byte is then masked with a corresponding hexadecimal value to place it in the correct position for the swapped output.
    - The results of these operations are combined using the bitwise OR operator to form the final swapped value.
- **Output**: The function returns a 64-bit unsigned integer with its byte order reversed.


---
### XXH\_readLE64<!-- {{#callable:XXH_readLE64}} -->
Reads a 64-bit little-endian integer from a pointer, swapping bytes if the CPU is not little-endian.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which the 64-bit integer is to be read.
- **Control Flow**:
    - Checks if the CPU architecture is little-endian using the `XXH_CPU_LITTLE_ENDIAN` macro.
    - If the architecture is little-endian, it directly reads the 64-bit integer using [`XXH_read64`](#XXH_read64).
    - If the architecture is not little-endian, it reads the 64-bit integer and then swaps the byte order using [`XXH_swap64`](#XXH_swap64).
- **Output**: Returns the 64-bit integer read from the specified memory location, correctly ordered based on the CPU's endianness.
- **Functions called**:
    - [`XXH_read64`](#XXH_read64)
    - [`XXH_swap64`](#XXH_swap64)


---
### XXH\_readBE64<!-- {{#callable:XXH_readBE64}} -->
Reads a 64-bit big-endian integer from a pointer, swapping bytes if the CPU is little-endian.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which the 64-bit integer is to be read.
- **Control Flow**:
    - Checks if the CPU architecture is little-endian using the `XXH_CPU_LITTLE_ENDIAN` macro.
    - If the CPU is little-endian, it calls [`XXH_swap64`](#XXH_swap64) on the result of `XXH_read64(ptr)` to convert the value to big-endian format.
    - If the CPU is not little-endian, it directly calls `XXH_read64(ptr)` to read the value.
- **Output**: Returns a 64-bit unsigned integer read from the specified memory location, correctly formatted based on the endianness of the CPU.
- **Functions called**:
    - [`XXH_swap64`](#XXH_swap64)
    - [`XXH_read64`](#XXH_read64)


---
### XXH\_readLE64\_align<!-- {{#callable:XXH_readLE64_align}} -->
Reads a 64-bit little-endian value from a pointer with alignment consideration.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which the 64-bit value is to be read.
    - `align`: An enumeration value indicating whether the read operation is aligned or unaligned.
- **Control Flow**:
    - Checks if the alignment is unaligned using the `align` parameter.
    - If unaligned, calls the [`XXH_readLE64`](#XXH_readLE64) function to read the value.
    - If aligned, checks the CPU endianness using `XXH_CPU_LITTLE_ENDIAN`.
    - If the CPU is little-endian, directly dereferences the pointer to read the value.
    - If the CPU is not little-endian, swaps the bytes of the read value using [`XXH_swap64`](#XXH_swap64).
- **Output**: Returns the 64-bit value read from the specified memory location, either directly or after byte-swapping based on the CPU endianness.
- **Functions called**:
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH_swap64`](#XXH_swap64)


---
### XXH64\_round<!-- {{#callable:XXH64_round}} -->
The `XXH64_round` function performs a single round of the XXH64 hash algorithm, updating the accumulator with a new input value.
- **Inputs**:
    - `acc`: The current accumulator value, which is updated during the hashing process.
    - `input`: The input value to be processed and incorporated into the hash.
- **Control Flow**:
    - The function first updates the accumulator by adding the product of the input and a constant `XXH_PRIME64_2`.
    - It then rotates the accumulator left by 31 bits using the `XXH_rotl64` function.
    - Next, the accumulator is multiplied by another constant `XXH_PRIME64_1`.
    - If the compiler supports AVX512 and autovectorization is disabled, a compiler fence is applied to prevent autovectorization of the loop.
    - Finally, the updated accumulator is returned.
- **Output**: The function returns the updated accumulator value after processing the input.


---
### XXH64\_mergeRound<!-- {{#callable:XXH64_mergeRound}} -->
`XXH64_mergeRound` merges a value into an accumulator using a specific hashing algorithm.
- **Inputs**:
    - `acc`: The current accumulator value, which is a 64-bit unsigned integer.
    - `val`: The value to be merged into the accumulator, also a 64-bit unsigned integer.
- **Control Flow**:
    - The function first processes the `val` input by calling the [`XXH64_round`](#XXH64_round) function with an initial seed of 0.
    - The processed `val` is then XORed with the `acc` to combine the two values.
    - The result is multiplied by `XXH_PRIME64_1` and then incremented by `XXH_PRIME64_4` to produce the final merged value.
- **Output**: The function returns the updated accumulator value after merging the input value.
- **Functions called**:
    - [`XXH64_round`](#XXH64_round)


---
### XXH64\_avalanche<!-- {{#callable:XXH64_avalanche}} -->
The `XXH64_avalanche` function applies a series of bitwise operations and multiplications to a 64-bit hash value to produce a final avalanche effect.
- **Inputs**:
    - `hash`: A 64-bit unsigned integer representing the initial hash value to be transformed.
- **Control Flow**:
    - The function begins by performing a bitwise XOR operation on `hash` with itself right-shifted by 33 bits.
    - Next, the modified `hash` is multiplied by a constant `XXH_PRIME64_2`.
    - The function then applies another XOR operation on `hash` with itself right-shifted by 29 bits.
    - This is followed by multiplying `hash` by another constant `XXH_PRIME64_3`.
    - Finally, a last XOR operation is performed on `hash` with itself right-shifted by 32 bits before returning the final value.
- **Output**: The function returns a 64-bit unsigned integer that represents the transformed hash value after applying the avalanche effect.


---
### XXH64\_finalize<!-- {{#callable:XXH64_finalize}} -->
Finalizes the XXH64 hash computation by processing the remaining input data.
- **Inputs**:
    - `hash`: The current hash value to be finalized.
    - `ptr`: Pointer to the input data to be processed.
    - `len`: The length of the input data in bytes.
    - `align`: Alignment information for the input data.
- **Control Flow**:
    - Checks if the input pointer `ptr` is NULL and asserts that `len` must be 0 in that case.
    - Masks the length `len` to ensure it does not exceed 31 bytes.
    - Processes the input data in chunks of 8 bytes using a loop, updating the hash with the results of [`XXH64_round`](#XXH64_round) and applying a series of transformations.
    - If there are 4 or more bytes remaining, processes the next 4 bytes, updating the hash accordingly.
    - Processes any remaining bytes one at a time, updating the hash for each byte.
    - Finally, applies the [`XXH64_avalanche`](#XXH64_avalanche) function to the hash to produce the final hash value.
- **Output**: Returns the finalized hash value after processing all input data.
- **Functions called**:
    - [`XXH64_round`](#XXH64_round)
    - [`XXH64_avalanche`](#XXH64_avalanche)


---
### XXH64\_endian\_align<!-- {{#callable:XXH64_endian_align}} -->
Calculates a 64-bit hash value from the input data with optional alignment and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, represented as an array of `xxh_u8`.
    - `len`: The length of the input data in bytes.
    - `seed`: A 64-bit unsigned integer used to initialize the hash calculation.
    - `align`: An enumeration value that specifies the alignment of the input data.
- **Control Flow**:
    - Checks if the input pointer is NULL and asserts that length is zero if true.
    - If the length of the input is 32 bytes or more, initializes four 64-bit variables with the seed and prime constants.
    - Enters a loop that processes 8 bytes of input at a time using the [`XXH64_round`](#XXH64_round) function until the input pointer reaches the limit.
    - After processing, combines the results of the four variables using bitwise rotations and the [`XXH64_mergeRound`](#XXH64_mergeRound) function.
    - If the length is less than 32, initializes the hash value with the seed and a prime constant.
    - Adds the length of the input to the hash value.
    - Finalizes the hash calculation by calling [`XXH64_finalize`](#XXH64_finalize) with the computed hash value, remaining input, length, and alignment.
- **Output**: Returns a 64-bit unsigned integer representing the final hash value of the input data.
- **Functions called**:
    - [`XXH64_round`](#XXH64_round)
    - [`XXH64_mergeRound`](#XXH64_mergeRound)
    - [`XXH64_finalize`](#XXH64_finalize)


---
### XXH64\_hash\_t<!-- {{#callable:XXH64_hash_t}} -->
Computes the XXH64 hash of the input data with a specified length and seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed`: A seed value used to initialize the hash computation.
- **Control Flow**:
    - The function checks if the macro `XXH_NO_STREAM` is not defined and if `XXH_SIZE_OPT` is greater than or equal to 2.
    - If the conditions are met, it initializes a `XXH64_state_t` state structure and calls [`XXH64_reset`](#XXH_errorcodeXXH64_reset) to set it up with the provided seed.
    - Next, it updates the state with the input data using [`XXH64_update`](#XXH_errorcodeXXH64_update) and finally returns the computed hash using [`XXH64_digest`](#XXH64_hash_tXXH64_digest).
    - If the conditions are not met, it checks if `XXH_FORCE_ALIGN_CHECK` is defined and if the input pointer is aligned to an 8-byte boundary.
    - If aligned, it calls [`XXH64_endian_align`](#XXH64_endian_align) with the aligned option; otherwise, it calls the same function with the unaligned option.
- **Output**: Returns the computed XXH64 hash as a value of type `XXH64_hash_t`.
- **Functions called**:
    - [`XXH_errorcode::XXH64_reset`](#XXH_errorcodeXXH64_reset)
    - [`XXH_errorcode::XXH64_update`](#XXH_errorcodeXXH64_update)
    - [`XXH64_hash_t::XXH64_digest`](#XXH64_hash_tXXH64_digest)
    - [`XXH64_endian_align`](#XXH64_endian_align)


---
### XXH64\_freeState<!-- {{#callable:XXH_errorcode::XXH64_freeState}} -->
Frees the memory allocated for a `XXH64_state_t` structure.
- **Inputs**:
    - `statePtr`: A pointer to the `XXH64_state_t` structure that needs to be freed.
- **Control Flow**:
    - The function calls [`XXH_free`](#XXH_free) with the provided `statePtr` to deallocate the memory.
    - After freeing the memory, it returns a success code `XXH_OK`.
- **Output**: Returns an `XXH_errorcode` indicating the success of the operation, specifically `XXH_OK`.
- **Functions called**:
    - [`XXH_free`](#XXH_free)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH64\_copyState<!-- {{#callable:XXH64_copyState}} -->
Copies the state from one `XXH64_state_t` structure to another.
- **Inputs**:
    - `dstState`: A pointer to the destination `XXH64_state_t` structure where the state will be copied to.
    - `srcState`: A pointer to the source `XXH64_state_t` structure from which the state will be copied.
- **Control Flow**:
    - The function uses [`XXH_memcpy`](#XXH_memcpy) to perform a memory copy operation.
    - It copies the entire size of the `XXH64_state_t` structure from `srcState` to `dstState`.
- **Output**: This function does not return a value; it modifies the `dstState` in place.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH64\_reset<!-- {{#callable:XXH_errorcode::XXH64_reset}} -->
Resets the state of a `XXH64_state_t` structure with a given seed.
- **Inputs**:
    - `statePtr`: A pointer to a `XXH64_state_t` structure that holds the state of the hash.
    - `seed`: A `XXH64_hash_t` value used to initialize the state.
- **Control Flow**:
    - Checks if `statePtr` is not NULL using `XXH_ASSERT` to ensure valid input.
    - Clears the memory of the `statePtr` structure using `memset` to initialize all fields to zero.
    - Sets the first four values of the `v` array in the `statePtr` based on the provided `seed` and predefined constants (`XXH_PRIME64_1` and `XXH_PRIME64_2`).
    - Returns `XXH_OK` to indicate successful completion of the reset operation.
- **Output**: Returns an `XXH_errorcode` indicating the success of the operation, specifically `XXH_OK`.
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH64\_update<!-- {{#callable:XXH_errorcode::XXH64_update}} -->
Updates the state of a `XXH64_state_t` object with new input data for the XXH64 hash algorithm.
- **Inputs**:
    - `state`: A pointer to an `XXH64_state_t` structure that holds the current state of the hash computation.
    - `input`: A pointer to the input data to be added to the hash state.
    - `len`: The length of the input data in bytes.
- **Control Flow**:
    - Checks if the `input` is NULL; if so, asserts that `len` is 0 and returns `XXH_OK`.
    - Converts the `input` pointer to a `const xxh_u8*` type and calculates the end of the input data.
    - Increments the total length of the data processed in the state.
    - If the combined size of the current memory and new input is less than 32 bytes, it copies the input into the temporary buffer and updates the memory size.
    - If there is already data in the temporary buffer, it fills the buffer, processes the data using [`XXH64_round`](#XXH64_round), and resets the memory size.
    - Processes full 32-byte chunks of data from the input, updating the state using [`XXH64_round`](#XXH64_round) for each chunk.
    - If there are remaining bytes after processing full chunks, it copies them into the temporary buffer for future processing.
- **Output**: Returns `XXH_OK` indicating successful update of the hash state.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)
    - [`XXH64_round`](#XXH64_round)
    - [`XXH_readLE64`](#XXH_readLE64)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH64\_digest<!-- {{#callable:XXH64_hash_t::XXH64_digest}} -->
Calculates the final 64-bit hash value from the given `XXH64_state_t` structure.
- **Inputs**:
    - `state`: A pointer to an `XXH64_state_t` structure that contains the current state of the hash computation, including the total length of the input and intermediate hash values.
- **Control Flow**:
    - Checks if the total length of the input data in `state` is 32 bytes or more.
    - If the total length is sufficient, it computes a preliminary hash value `h64` by rotating and summing the first four values in `state->v` and merging them with [`XXH64_mergeRound`](#XXH64_mergeRound).
    - If the total length is less than 32 bytes, it initializes `h64` with the third value in `state->v` plus a constant `XXH_PRIME64_5`.
    - Adds the total length of the input data to `h64` to incorporate the length into the final hash.
    - Calls [`XXH64_finalize`](#XXH64_finalize) to produce the final hash value using `h64`, the memory buffer from `state`, and the total length.
- **Output**: Returns a 64-bit hash value of type `XXH64_hash_t` that represents the computed hash based on the state provided.
- **Functions called**:
    - [`XXH64_mergeRound`](#XXH64_mergeRound)
    - [`XXH64_finalize`](#XXH64_finalize)


---
### XXH64\_canonicalFromHash<!-- {{#callable:XXH64_canonicalFromHash}} -->
Converts a 64-bit hash value into its canonical form.
- **Inputs**:
    - `dst`: A pointer to a `XXH64_canonical_t` structure where the canonical hash will be stored.
    - `hash`: A 64-bit hash value of type `XXH64_hash_t` that needs to be converted.
- **Control Flow**:
    - The function asserts that the size of `XXH64_canonical_t` is equal to the size of `XXH64_hash_t` using a static assertion.
    - It checks if the CPU architecture is little-endian; if true, it swaps the byte order of the `hash` using [`XXH_swap64`](#XXH_swap64).
    - Finally, it copies the (potentially swapped) `hash` value into the memory location pointed to by `dst` using [`XXH_memcpy`](#XXH_memcpy).
- **Output**: The function does not return a value; instead, it writes the canonical form of the hash directly to the provided destination pointer.
- **Functions called**:
    - [`XXH_swap64`](#XXH_swap64)
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH64\_hashFromCanonical<!-- {{#callable:XXH64_hash_t::XXH64_hashFromCanonical}} -->
Calculates a 64-bit hash from a canonical representation using big-endian reading.
- **Inputs**:
    - `src`: A pointer to a `XXH64_canonical_t` structure that contains the canonical data to be hashed.
- **Control Flow**:
    - The function directly calls [`XXH_readBE64`](#XXH_readBE64) with the provided `src` pointer.
    - No conditional statements or loops are present; the function executes a single operation.
- **Output**: Returns a 64-bit hash value of type `XXH64_hash_t` obtained by reading the data from the `src` pointer in big-endian format.
- **Functions called**:
    - [`XXH_readBE64`](#XXH_readBE64)


---
### XXH\_vld1q\_u64<!-- {{#callable:XXH_vld1q_u64}} -->
Loads 128 bits of data from memory and interprets it as two 64-bit unsigned integers.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which 128 bits of data will be loaded.
- **Control Flow**:
    - The function uses `vld1q_u8` to load 16 bytes (128 bits) of data from the memory address pointed to by `ptr`.
    - The loaded data is then reinterpreted from an array of 8-bit unsigned integers to an array of 64-bit unsigned integers using `vreinterpretq_u64_u8`.
- **Output**: Returns a `uint64x2_t` type, which contains two 64-bit unsigned integers loaded from the specified memory location.


---
### XXH\_vmlal\_low\_u32<!-- {{#callable:XXH_vmlal_low_u32}} -->
Performs a vectorized multiply-accumulate operation on the lower 32 bits of two 4-element vectors.
- **Inputs**:
    - `acc`: A `uint64x2_t` vector that accumulates the results of the multiplication.
    - `lhs`: A `uint32x4_t` vector containing the first set of 32-bit integers for multiplication.
    - `rhs`: A `uint32x4_t` vector containing the second set of 32-bit integers for multiplication.
- **Control Flow**:
    - The function uses the `vget_low_u32` intrinsic to extract the lower 32 bits from both `lhs` and `rhs` vectors.
    - It then calls the `vmlal_u32` intrinsic to perform the multiply-accumulate operation using the extracted lower 32-bit values and the accumulator `acc`.
- **Output**: Returns a `uint64x2_t` vector that contains the result of the multiply-accumulate operation.


---
### XXH\_vmlal\_high\_u32<!-- {{#callable:XXH_vmlal_high_u32}} -->
The `XXH_vmlal_high_u32` function performs a vectorized multiplication-accumulation operation on the high 32 bits of two 4-element vectors.
- **Inputs**:
    - `acc`: A `uint64x2_t` type accumulator that holds the current accumulated result of the multiplication.
    - `lhs`: A `uint32x4_t` type vector containing the first set of 32-bit unsigned integers.
    - `rhs`: A `uint32x4_t` type vector containing the second set of 32-bit unsigned integers.
- **Control Flow**:
    - The function retrieves the high 32 bits from both the `lhs` and `rhs` vectors using `vget_high_u32`.
    - It then calls the `vmlal_u32` intrinsic to multiply the high 32 bits of `lhs` and `rhs`, adding the result to the `acc` accumulator.
- **Output**: The function returns a `uint64x2_t` type result that contains the updated accumulated value after the multiplication-accumulation operation.


---
### XXH\_vec\_revb<!-- {{#callable:XXH_vec_revb}} -->
The `XXH_vec_revb` function performs a byte reversal on a 128-bit vector of unsigned 64-bit integers.
- **Inputs**:
    - `val`: A `xxh_u64x2` type representing a 128-bit vector containing two unsigned 64-bit integers that will be byte-swapped.
- **Control Flow**:
    - The function defines a constant `vByteSwap` which is an array of 16 bytes that specifies the order for byte swapping.
    - It uses the `vec_perm` intrinsic to permute the bytes of the input vector `val` according to the order defined in `vByteSwap`.
    - The result of the permutation, which is the byte-reversed vector, is returned.
- **Output**: The function returns a `xxh_u64x2` type that contains the byte-reversed version of the input vector `val`.


---
### XXH\_vec\_loadu<!-- {{#callable:XXH_vec_loadu}} -->
Loads a 128-bit vector from memory and optionally reverses the byte order based on the architecture.
- **Inputs**:
    - `ptr`: A pointer to the memory location from which the 128-bit vector will be loaded.
- **Control Flow**:
    - The function initializes a variable `ret` of type `xxh_u64x2` to hold the loaded vector.
    - It uses [`XXH_memcpy`](#XXH_memcpy) to copy data from the memory location pointed to by `ptr` into `ret`.
    - If the macro `XXH_VSX_BE` is defined, indicating a big-endian architecture, it calls [`XXH_vec_revb`](#XXH_vec_revb) to reverse the byte order of `ret`.
    - Finally, it returns the loaded (and possibly byte-reversed) vector.
- **Output**: Returns a `xxh_u64x2` type containing the loaded 128-bit vector from memory.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)
    - [`XXH_vec_revb`](#XXH_vec_revb)


---
### XXH\_vec\_mulo<!-- {{#callable:XXH_vec_mulo}} -->
Multiplies two vectors of 32-bit unsigned integers and returns the result as a vector of 64-bit unsigned integers.
- **Inputs**:
    - `a`: A vector of four 32-bit unsigned integers.
    - `b`: A vector of four 32-bit unsigned integers.
- **Control Flow**:
    - The function uses inline assembly to perform a vector multiplication operation.
    - The `vmulouw` instruction multiplies the corresponding elements of the input vectors `a` and `b`.
    - The result of the multiplication is stored in the `result` variable.
- **Output**: Returns a vector of two 64-bit unsigned integers containing the products of the corresponding elements of the input vectors.


---
### XXH\_vec\_mule<!-- {{#callable:XXH_vec_mule}} -->
The `XXH_vec_mule` function performs a vectorized multiplication of two 128-bit vectors using SIMD instructions.
- **Inputs**:
    - `a`: A 128-bit vector of four 32-bit unsigned integers to be multiplied.
    - `b`: A 128-bit vector of four 32-bit unsigned integers to be multiplied with vector `a`.
- **Control Flow**:
    - The function begins by declaring a variable `result` to hold the output of the multiplication.
    - It uses inline assembly to execute the SIMD instruction `vmuleuw`, which multiplies the corresponding elements of the two input vectors `a` and `b`.
    - The result of the multiplication is stored in the `result` variable.
    - Finally, the function returns the `result` variable containing the multiplication results.
- **Output**: The function outputs a 128-bit vector (`xxh_u64x2`) containing the results of the element-wise multiplication of the input vectors `a` and `b`.


---
### XXH\_mult32to64<!-- {{#callable:XXH_mult32to64}} -->
Multiplies the lower 32 bits of two 64-bit unsigned integers and returns the result.
- **Inputs**:
    - `x`: A 64-bit unsigned integer whose lower 32 bits will be used in the multiplication.
    - `y`: A 64-bit unsigned integer whose lower 32 bits will be used in the multiplication.
- **Control Flow**:
    - The function extracts the lower 32 bits of both input integers `x` and `y` using a bitwise AND operation with `0xFFFFFFFF`.
    - It then multiplies these two extracted 32-bit values together.
    - The result of the multiplication is returned as a 64-bit unsigned integer.
- **Output**: The function outputs a 64-bit unsigned integer that is the product of the lower 32 bits of the inputs `x` and `y`.


---
### XXH\_mult64to128<!-- {{#callable:XXH_mult64to128}} -->
Multiplies two 64-bit unsigned integers and returns the result as a 128-bit unsigned integer.
- **Inputs**:
    - `lhs`: The left-hand side 64-bit unsigned integer to be multiplied.
    - `rhs`: The right-hand side 64-bit unsigned integer to be multiplied.
- **Control Flow**:
    - Checks if the compiler supports the `__uint128_t` type for 128-bit multiplication.
    - If supported, performs multiplication using `__uint128_t` and extracts the lower and higher 64 bits.
    - If not supported, checks for MSVC x64 and uses the `_umul128` intrinsic for multiplication.
    - If on ARM64, uses the `__umulh` intrinsic for multiplication.
    - If none of the above methods are available, falls back to a portable scalar multiplication method.
    - Calculates the lower and upper parts of the product using cross products and adds them together.
- **Output**: Returns a `XXH128_hash_t` structure containing the lower and upper 64 bits of the 128-bit product.
- **Functions called**:
    - [`XXH_mult32to64`](#XXH_mult32to64)


---
### XXH3\_mul128\_fold64<!-- {{#callable:XXH3_mul128_fold64}} -->
Computes a 64-bit hash by multiplying two 64-bit integers and folding the result.
- **Inputs**:
    - `lhs`: The left-hand side 64-bit integer to be multiplied.
    - `rhs`: The right-hand side 64-bit integer to be multiplied.
- **Control Flow**:
    - Calls the [`XXH_mult64to128`](#XXH_mult64to128) function to multiply `lhs` and `rhs`, resulting in a 128-bit product.
    - Extracts the low and high 64 bits of the product and performs a bitwise XOR operation on them.
- **Output**: Returns a 64-bit integer that is the result of XORing the low and high parts of the 128-bit product.
- **Functions called**:
    - [`XXH_mult64to128`](#XXH_mult64to128)


---
### XXH\_xorshift64<!-- {{#callable:XXH_xorshift64}} -->
Performs a bitwise XOR operation on a 64-bit unsigned integer with its right-shifted version.
- **Inputs**:
    - `v64`: A 64-bit unsigned integer that will be manipulated.
    - `shift`: An integer specifying the number of bits to right-shift `v64` before performing the XOR operation.
- **Control Flow**:
    - The function begins by asserting that the `shift` value is within the valid range (0 to 63).
    - If the assertion passes, it computes the result by right-shifting `v64` by `shift` bits and then performing a bitwise XOR with the original `v64`.
- **Output**: Returns the result of the XOR operation, which is a 64-bit unsigned integer.


---
### XXH3\_avalanche<!-- {{#callable:XXH3_avalanche}} -->
The `XXH3_avalanche` function applies a series of transformations to a 64-bit hash value.
- **Inputs**:
    - `h64`: A 64-bit unsigned integer representing the hash value to be transformed.
- **Control Flow**:
    - The function begins by applying a bitwise XOR shift operation to `h64` using a shift of 37 bits, modifying its value.
    - Next, the modified `h64` is multiplied by a constant `PRIME_MX1` to further alter its value.
    - Finally, another XOR shift operation is applied to the result with a shift of 32 bits before returning the final value.
- **Output**: The function returns a transformed 64-bit unsigned integer hash value after applying the specified operations.
- **Functions called**:
    - [`XXH_xorshift64`](#XXH_xorshift64)


---
### XXH3\_rrmxmx<!-- {{#callable:XXH3_rrmxmx}} -->
The `XXH3_rrmxmx` function performs a series of mixing operations on a 64-bit hash value based on the input length.
- **Inputs**:
    - `h64`: A 64-bit unsigned integer representing the initial hash value.
    - `len`: A 64-bit unsigned integer representing the length of the data being hashed.
- **Control Flow**:
    - The function begins by mixing the input hash `h64` using bitwise operations and rotations to enhance randomness.
    - It multiplies the mixed hash by a constant `PRIME_MX2` to further scramble the value.
    - The function then incorporates the input length `len` into the hash by adding it to the right-shifted value of `h64` and performing another multiplication with `PRIME_MX2`.
    - Finally, it applies a final transformation using the [`XXH_xorshift64`](#XXH_xorshift64) function to produce the final hash value.
- **Output**: The function returns a 64-bit hash value that is the result of the mixing operations applied to the input hash and length.
- **Functions called**:
    - [`XXH_xorshift64`](#XXH_xorshift64)


---
### XXH3\_len\_1to3\_64b<!-- {{#callable:XXH3_len_1to3_64b}} -->
Computes a 64-bit hash for input strings of length 1 to 3 using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input byte array to be hashed, which must not be NULL.
    - `len`: The length of the input array, which must be between 1 and 3.
    - `secret`: A pointer to a secret byte array used for hashing, which must not be NULL.
    - `seed`: A 64-bit hash seed used to modify the hash output.
- **Control Flow**:
    - The function begins by asserting that the input is not NULL and that the length is between 1 and 3.
    - It also asserts that the secret is not NULL.
    - Depending on the length of the input, it selects specific bytes from the input to create a combined value.
    - The combined value is constructed using bitwise operations to pack the selected bytes and the length into a 32-bit integer.
    - A bitflip value is computed by reading from the secret and XORing it with the seed.
    - The combined value is then XORed with the bitflip value to produce a keyed hash value.
    - Finally, the function returns the result of the [`XXH64_avalanche`](#XXH64_avalanche) function applied to the keyed value.
- **Output**: Returns a 64-bit hash value computed from the input, length, secret, and seed.
- **Functions called**:
    - [`XXH_readLE32`](#XXH_readLE32)
    - [`XXH64_avalanche`](#XXH64_avalanche)


---
### XXH3\_len\_4to8\_64b<!-- {{#callable:XXH3_len_4to8_64b}} -->
Computes a 64-bit hash for input data of length between 4 and 8 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data of type `xxh_u8` that needs to be hashed.
    - `len`: The length of the input data, which must be between 4 and 8 bytes.
    - `secret`: A pointer to a secret key of type `xxh_u8` used in the hashing process.
    - `seed`: A 64-bit hash seed of type `XXH64_hash_t` that is used to modify the hash output.
- **Control Flow**:
    - The function begins by asserting that the input and secret pointers are not NULL and that the length is between 4 and 8.
    - The seed is modified by XORing it with a bit-shifted version of itself.
    - The function reads the first 4 bytes and the last 4 bytes of the input data into `input1` and `input2` respectively.
    - It computes a `bitflip` value by XORing two 64-bit values from the secret key and subtracting the seed.
    - The two 32-bit input values are combined into a 64-bit value `input64`.
    - The `input64` is XORed with the `bitflip` to create a `keyed` value.
    - Finally, the function calls [`XXH3_rrmxmx`](#XXH3_rrmxmx) with the `keyed` value and the length to produce the final hash.
- **Output**: Returns a 64-bit hash of type `XXH64_hash_t` computed from the input data, secret key, and seed.
- **Functions called**:
    - [`XXH_swap32`](#XXH_swap32)
    - [`XXH_readLE32`](#XXH_readLE32)
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH3_rrmxmx`](#XXH3_rrmxmx)


---
### XXH3\_len\_9to16\_64b<!-- {{#callable:XXH3_len_9to16_64b}} -->
Computes a 64-bit hash for input strings of length between 9 and 16 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input byte array that needs to be hashed, which must not be NULL.
    - `len`: The length of the input byte array, which must be between 9 and 16 inclusive.
    - `secret`: A pointer to a secret byte array used for hashing, which must not be NULL.
    - `seed`: A 64-bit hash seed used to influence the hash output.
- **Control Flow**:
    - The function begins by asserting that the input and secret pointers are not NULL and that the length is between 9 and 16.
    - It calculates two bitflip values using the secret array and the provided seed.
    - The function reads the first 8 bytes of the input and the last 8 bytes of the input, applying the corresponding bitflip values.
    - An accumulator value is computed using the length, the swapped lower input value, the higher input value, and a multiplication fold operation.
    - Finally, the accumulator is passed to the [`XXH3_avalanche`](#XXH3_avalanche) function to produce the final hash value.
- **Output**: Returns a 64-bit hash value computed from the input data, influenced by the secret and seed.
- **Functions called**:
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH_swap64`](#XXH_swap64)
    - [`XXH3_mul128_fold64`](#XXH3_mul128_fold64)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH3\_len\_0to16\_64b<!-- {{#callable:XXH3_len_0to16_64b}} -->
Computes a 64-bit hash for input data of length between 0 and 16 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, which is of type `xxh_u8`.
    - `len`: The length of the input data in bytes, which must be less than or equal to 16.
    - `secret`: A pointer to a secret key used in the hashing process, also of type `xxh_u8`.
    - `seed`: A 64-bit hash seed of type `XXH64_hash_t` used to initialize the hash computation.
- **Control Flow**:
    - The function asserts that the length of the input does not exceed 16 bytes.
    - If the length is greater than 8, it calls [`XXH3_len_9to16_64b`](#XXH3_len_9to16_64b) to handle the hashing for lengths 9 to 16.
    - If the length is between 4 and 8, it calls [`XXH3_len_4to8_64b`](#XXH3_len_4to8_64b) for hashing.
    - If the length is between 1 and 3, it calls [`XXH3_len_1to3_64b`](#XXH3_len_1to3_64b) for hashing.
    - If the length is 0, it computes a hash using the seed and two values read from the secret key.
- **Output**: Returns a 64-bit hash of type `XXH64_hash_t` based on the input data, secret key, and seed.
- **Functions called**:
    - [`XXH3_len_9to16_64b`](#XXH3_len_9to16_64b)
    - [`XXH3_len_4to8_64b`](#XXH3_len_4to8_64b)
    - [`XXH3_len_1to3_64b`](#XXH3_len_1to3_64b)
    - [`XXH64_avalanche`](#XXH64_avalanche)
    - [`XXH_readLE64`](#XXH_readLE64)


---
### XXH3\_mix16B<!-- {{#callable:XXH3_mix16B}} -->
Mixes two 64-bit input values with a secret key and a seed to produce a 128-bit hash.
- **Inputs**:
    - `input`: A pointer to an array of 16 bytes (128 bits) of input data to be mixed.
    - `secret`: A pointer to an array of 16 bytes (128 bits) of secret data used in the mixing process.
    - `seed64`: A 64-bit seed value that influences the mixing of the input and secret data.
- **Control Flow**:
    - The function first reads the lower and upper 64 bits of the input data using [`XXH_readLE64`](#XXH_readLE64).
    - It then mixes these values with corresponding values from the secret data and the seed.
    - The mixing is done using the XOR operation and the [`XXH3_mul128_fold64`](#XXH3_mul128_fold64) function, which combines the results into a final hash value.
- **Output**: Returns a 64-bit hash value that is the result of the mixing process.
- **Functions called**:
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH3_mul128_fold64`](#XXH3_mul128_fold64)


---
### XXH3\_len\_17to128\_64b<!-- {{#callable:XXH3_len_17to128_64b}} -->
Computes a 64-bit hash for input data of length between 17 and 128 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, which must be between 17 and 128 bytes long.
    - `len`: The length of the input data in bytes.
    - `secret`: A pointer to the secret key used for hashing, which must be at least XXH3_SECRET_SIZE_MIN bytes long.
    - `secretSize`: The size of the secret key in bytes.
    - `seed`: A 64-bit seed value used to initialize the hash computation.
- **Control Flow**:
    - The function asserts that the secret size is at least XXH3_SECRET_SIZE_MIN and that the input length is between 17 and 128 bytes.
    - An accumulator `acc` is initialized based on the input length multiplied by a prime constant.
    - Depending on the length of the input, the function either uses a loop to mix 16-byte chunks of the input and secret or follows a series of conditional statements to mix specific chunks.
    - The mixing is done using the [`XXH3_mix16B`](#XXH3_mix16B) function, which combines parts of the input and secret to update the accumulator.
    - Finally, the accumulator is passed to the [`XXH3_avalanche`](#XXH3_avalanche) function to produce the final hash value.
- **Output**: Returns a 64-bit hash value computed from the input data, secret key, and seed after applying the mixing and avalanche processes.
- **Functions called**:
    - [`XXH3_mix16B`](#XXH3_mix16B)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH3\_len\_129to240\_64b<!-- {{#callable:XXH3_len_129to240_64b}} -->
Computes a 64-bit hash for input data of length between 129 and 240 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, which must be between 129 and 240 bytes in length.
    - `len`: The length of the input data in bytes, which must be greater than 128 and less than or equal to XXH3_MIDSIZE_MAX.
    - `secret`: A pointer to the secret key used for hashing, which must be at least XXH3_SECRET_SIZE_MIN bytes long.
    - `secretSize`: The size of the secret key in bytes, which must be at least XXH3_SECRET_SIZE_MIN.
    - `seed`: A 64-bit seed value used to initialize the hash computation.
- **Control Flow**:
    - The function begins by asserting that the secret size is at least XXH3_SECRET_SIZE_MIN and that the input length is within the valid range.
    - An accumulator `acc` is initialized based on the input length multiplied by a prime constant.
    - The function computes the number of rounds based on the input length divided by 16.
    - A loop iterates 8 times to mix the first 8 blocks of 16 bytes from the input and secret into the accumulator.
    - The last 16 bytes are mixed into a separate accumulator `acc_end` using a specific offset from the secret.
    - A second loop processes the remaining rounds, mixing additional blocks of input and secret into `acc_end`.
    - Finally, the function returns the result of the avalanche function applied to the sum of `acc` and `acc_end`.
- **Output**: Returns a 64-bit hash value computed from the input data, secret key, and seed after applying the avalanche transformation.
- **Functions called**:
    - [`XXH3_mix16B`](#XXH3_mix16B)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH\_writeLE64<!-- {{#callable:XXH_writeLE64}} -->
Writes a 64-bit unsigned integer to a destination pointer in little-endian format.
- **Inputs**:
    - `dst`: A pointer to the destination memory location where the 64-bit value will be written.
    - `v64`: The 64-bit unsigned integer value to be written to the destination.
- **Control Flow**:
    - Checks if the CPU architecture is not little-endian.
    - If the architecture is big-endian, the function swaps the byte order of `v64` using [`XXH_swap64`](#XXH_swap64).
    - Copies the (potentially swapped) value of `v64` to the memory location pointed to by `dst` using [`XXH_memcpy`](#XXH_memcpy).
- **Output**: The function does not return a value; it directly modifies the memory at the specified destination.
- **Functions called**:
    - [`XXH_swap64`](#XXH_swap64)
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH3\_accumulate\_512\_avx512<!-- {{#callable:XXH3_accumulate_512_avx512}} -->
Accumulates a 512-bit hash value using AVX-512 instructions by processing input data with a secret key.
- **Inputs**:
    - `acc`: A pointer to a 512-bit accumulator where the result will be stored.
    - `input`: A pointer to the input data that will be processed.
    - `secret`: A pointer to a secret key used for hashing.
- **Control Flow**:
    - The function begins by asserting that the `acc` pointer is aligned to a 64-byte boundary.
    - It loads 512 bits of input data and the secret key into SIMD registers using `_mm512_loadu_si512`.
    - The input data is XORed with the secret key to create a `data_key`.
    - The lower 32 bits of `data_key` are extracted and shifted right by 32 bits to create `data_key_lo`.
    - The product of the lower 32 bits of `data_key` and `data_key_lo` is computed using `_mm512_mul_epu32`.
    - The input data is shuffled and added to the accumulator, and the product is also added to the accumulator.
- **Output**: The function modifies the accumulator in place, resulting in a new 512-bit hash value that incorporates the processed input and secret key.


---
### XXH3\_scrambleAcc\_avx512<!-- {{#callable:XXH3_scrambleAcc_avx512}} -->
`XXH3_scrambleAcc_avx512` scrambles a 512-bit accumulator using a secret key and specific bitwise operations.
- **Inputs**:
    - `acc`: A pointer to a 512-bit accumulator that will be scrambled.
    - `secret`: A pointer to a secret key used in the scrambling process.
- **Control Flow**:
    - The function begins by asserting that the `acc` pointer is aligned to a 64-byte boundary.
    - It then checks that the size of the stripe length is equal to the size of a 512-bit integer.
    - The accumulator is cast to a pointer of type `__m512i` for AVX-512 operations.
    - A constant vector `prime32` is initialized with the value of `XXH_PRIME32_1`.
    - The accumulator value is shifted right by 47 bits and stored in `shifted`.
    - The secret key is loaded into a vector `key_vec`.
    - A ternary logic operation combines `key_vec`, `acc_vec`, and `shifted` to produce `data_key`.
    - The lower and higher parts of `data_key` are multiplied by `prime32` to produce `prod_lo` and `prod_hi` respectively.
    - Finally, the new scrambled value is stored back into the accumulator.
- **Output**: The function does not return a value; instead, it modifies the accumulator in place with the scrambled result.


---
### XXH3\_initCustomSecret\_avx512<!-- {{#callable:XXH3_initCustomSecret_avx512}} -->
Initializes a custom secret for the XXH3 hash function using AVX512 instructions.
- **Inputs**:
    - `customSecret`: A pointer to a memory location where the custom secret will be stored, which must be aligned to 64 bytes.
    - `seed64`: A 64-bit integer seed used to modify the initialization of the custom secret.
- **Control Flow**:
    - The function begins by asserting that the default secret size is a multiple of 64 and that the alignment is correct.
    - It checks that the `customSecret` pointer is also aligned to 64 bytes.
    - The number of rounds for initialization is calculated based on the default secret size divided by the size of a 512-bit integer.
    - A seed value is prepared by creating a 512-bit vector initialized with the provided `seed64` and modifying it with a mask.
    - A loop iterates over the number of rounds, loading values from a predefined secret and adding the seed to each value before storing it in the `customSecret`.
- **Output**: The function does not return a value; instead, it populates the memory pointed to by `customSecret` with the initialized secret values.


---
### XXH3\_accumulate\_512\_avx2<!-- {{#callable:XXH3_accumulate_512_avx2}} -->
Accumulates a 512-bit hash value using AVX2 instructions by processing input data with a secret key.
- **Inputs**:
    - `acc`: A pointer to a 512-bit accumulator where the result will be stored, aligned to a 32-byte boundary.
    - `input`: A pointer to the input data that will be processed, treated as an array of 256-bit vectors.
    - `secret`: A pointer to a secret key used for hashing, also treated as an array of 256-bit vectors.
- **Control Flow**:
    - The function begins by asserting that the `acc` pointer is aligned to a 32-byte boundary.
    - It casts the input pointers to `__m256i` types for AVX2 operations.
    - A loop iterates over the number of 256-bit segments in the input data, determined by `XXH_STRIPE_LEN`.
    - Within the loop, it loads the input and secret key vectors, performs an XOR operation, and computes a product of the lower 32 bits.
    - The function then shuffles the data vector, adds it to the accumulator, and finally adds the product to the accumulator.
- **Output**: The function modifies the accumulator in place, resulting in a 512-bit hash value that incorporates the input data and secret key.


---
### XXH3\_scrambleAcc\_avx2<!-- {{#callable:XXH3_scrambleAcc_avx2}} -->
The `XXH3_scrambleAcc_avx2` function scrambles an accumulator using AVX2 instructions and a secret key.
- **Inputs**:
    - `acc`: A pointer to the accumulator data that will be scrambled, which must be aligned to a 32-byte boundary.
    - `secret`: A pointer to the secret key data used for scrambling the accumulator.
- **Control Flow**:
    - The function begins by asserting that the `acc` pointer is 32-byte aligned.
    - It casts the `acc` pointer to a pointer of type `__m256i` for AVX2 operations.
    - It also casts the `secret` pointer to a `const __m256i` pointer for loading the secret key.
    - A loop iterates over the number of `__m256i` elements in the accumulator, defined by `XXH_STRIPE_LEN/sizeof(__m256i)`.
    - Within the loop, it performs a series of operations on each element of the accumulator: it shifts the accumulator right by 47 bits, XORs it with the original value, XORs the result with the corresponding secret key, and then multiplies the result by a prime constant.
    - Finally, the scrambled value is stored back into the accumulator.
- **Output**: The function modifies the accumulator in place, scrambling its contents based on the provided secret key.


---
### XXH3\_initCustomSecret\_avx2<!-- {{#callable:XXH3_initCustomSecret_avx2}} -->
Initializes a custom secret for the XXH3 hash function using AVX2 instructions.
- **Inputs**:
    - `customSecret`: A pointer to a memory location where the custom secret will be stored.
    - `seed64`: A 64-bit unsigned integer used as a seed for initializing the custom secret.
- **Control Flow**:
    - The function begins by asserting that the default secret size is a multiple of 32 and that it is correctly aligned.
    - It prefetches the `customSecret` pointer to optimize memory access.
    - A 256-bit vector `seed` is created using the provided `seed64`, which is used to modify the secret.
    - The function loads predefined secret values from `XXH3_kSecret` and adds the `seed` to each of these values in a loop.
    - The results are stored in the memory location pointed to by `customSecret`.
- **Output**: The function does not return a value; instead, it modifies the memory at the location pointed to by `customSecret` to store the initialized custom secret.


---
### XXH3\_accumulate\_512\_sse2<!-- {{#callable:XXH3_accumulate_512_sse2}} -->
Accumulates a 512-bit hash value using SSE2 instructions by processing input data with a secret key.
- **Inputs**:
    - `acc`: A pointer to a 512-bit accumulator where the result will be stored.
    - `input`: A pointer to the input data that will be processed.
    - `secret`: A pointer to a secret key used for hashing.
- **Control Flow**:
    - The function begins by asserting that the `acc` pointer is aligned to a 16-byte boundary.
    - It casts the input pointers to `__m128i` types for SSE2 operations.
    - A loop iterates over the number of 128-bit chunks in the input data, determined by `XXH_STRIPE_LEN`.
    - Within the loop, it loads the data and secret key vectors using `_mm_loadu_si128`.
    - It computes a XOR of the data and key vectors to create a `data_key` vector.
    - The lower 32 bits of `data_key` are extracted and shuffled to create `data_key_lo`.
    - A product of the lower 32 bits of `data_key` is calculated using `_mm_mul_epu32`.
    - The original data vector is shuffled to create `data_swap`.
    - The accumulator is updated by adding `data_swap` and the product to the current value in `xacc`.
- **Output**: The function modifies the accumulator in place, resulting in a 512-bit hash value that incorporates the processed input data and secret key.


---
### XXH3\_scrambleAcc\_sse2<!-- {{#callable:XXH3_scrambleAcc_sse2}} -->
The `XXH3_scrambleAcc_sse2` function scrambles an accumulator using SSE2 instructions and a secret key.
- **Inputs**:
    - `acc`: A pointer to the accumulator data that will be scrambled, which must be aligned to a 16-byte boundary.
    - `secret`: A pointer to the secret key data used for scrambling the accumulator.
- **Control Flow**:
    - The function asserts that the `acc` pointer is aligned to a 16-byte boundary.
    - It casts the `acc` pointer to a pointer of type `__m128i` for SIMD operations.
    - It also casts the `secret` pointer to a pointer of type `const __m128i`.
    - A loop iterates over the number of `__m128i` elements in the accumulator, defined by `XXH_STRIPE_LEN/sizeof(__m128i)`.
    - Within the loop, it performs a series of operations on each `__m128i` element of the accumulator, including bitwise shifts, XOR operations with the secret key, and multiplications with a prime constant.
- **Output**: The function modifies the accumulator in place, scrambling its contents based on the provided secret key and specific mathematical operations.


---
### XXH3\_initCustomSecret\_sse2<!-- {{#callable:XXH3_initCustomSecret_sse2}} -->
Initializes a custom secret for the XXH3 hash function using SSE2 instructions.
- **Inputs**:
    - `customSecret`: A pointer to a memory location where the custom secret will be stored.
    - `seed64`: A 64-bit unsigned integer used as a seed for initializing the secret.
- **Control Flow**:
    - The function begins by asserting that the default secret size is a multiple of 16 bytes.
    - It defines the number of rounds for initialization based on the default secret size divided by the size of a 128-bit integer (__m128i).
    - Depending on the compiler and architecture, it initializes a 128-bit integer 'seed' either by loading two 64-bit integers or by using a specific intrinsic function.
    - It asserts the alignment of the source secret and destination pointers to ensure they are 16-byte aligned.
    - A loop iterates over the number of rounds, adding the seed to each 128-bit chunk of the default secret and storing the result in the custom secret.
- **Output**: The function does not return a value; instead, it modifies the memory pointed to by 'customSecret' to contain the initialized secret.


---
### XXH3\_accumulate\_512\_neon<!-- {{#callable:XXH3_accumulate_512_neon}} -->
Accumulates hash values using NEON SIMD instructions for enhanced performance.
- **Inputs**:
    - `acc`: A pointer to the accumulator where the results will be stored, aligned to 16 bytes.
    - `input`: A pointer to the input data that will be processed.
    - `secret`: A pointer to the secret key used in the hashing process.
- **Control Flow**:
    - The function begins by asserting that the `acc` pointer is 16-byte aligned.
    - It checks that the number of NEON lanes is valid and within the expected range.
    - The function processes the input data in two stages: first using a scalar approach for lanes beyond the NEON lanes, and then using NEON SIMD instructions for parallel processing.
    - In the NEON processing loop, it loads data and secret values, performs bitwise operations, and accumulates results using vectorized instructions.
    - The function handles both full and remaining NEON lanes, ensuring all data is processed efficiently.
- **Output**: The function does not return a value; instead, it updates the accumulator pointed to by `acc` with the computed hash values.
- **Functions called**:
    - [`XXH3_scalarRound`](#XXH3_scalarRound)
    - [`XXH_vld1q_u64`](#XXH_vld1q_u64)
    - [`XXH_vmlal_low_u32`](#XXH_vmlal_low_u32)
    - [`XXH_vmlal_high_u32`](#XXH_vmlal_high_u32)


---
### XXH3\_scrambleAcc\_neon<!-- {{#callable:XXH3_scrambleAcc_neon}} -->
The `XXH3_scrambleAcc_neon` function scrambles an accumulator using NEON SIMD instructions and a secret key.
- **Inputs**:
    - `acc`: A pointer to the accumulator that will be scrambled, which must be aligned to a 16-byte boundary.
    - `secret`: A pointer to the secret key used in the scrambling process.
- **Control Flow**:
    - The function asserts that the `acc` pointer is 16-byte aligned.
    - It initializes local variables for the accumulator and secret key, casting them to appropriate types.
    - If not compiling for WASM, it defines constants for the prime value used in scrambling.
    - It first scrambles the accumulator using a scalar method for indices beyond the NEON lanes.
    - Then, for each pair of lanes in the NEON vector, it performs a series of bitwise operations and multiplications to scramble the accumulator with the secret key.
- **Output**: The function does not return a value; it modifies the accumulator in place based on the scrambling algorithm.
- **Functions called**:
    - [`XXH3_scalarScrambleRound`](#XXH3_scalarScrambleRound)
    - [`XXH_vld1q_u64`](#XXH_vld1q_u64)


---
### XXH3\_accumulate\_512\_vsx<!-- {{#callable:XXH3_accumulate_512_vsx}} -->
The `XXH3_accumulate_512_vsx` function accumulates hash values using vectorized operations on input data and a secret key.
- **Inputs**:
    - `acc`: A pointer to the accumulator where the intermediate hash values are stored.
    - `input`: A pointer to the input data that will be processed for hashing.
    - `secret`: A pointer to the secret key used in the hashing process.
- **Control Flow**:
    - The function begins by casting the input pointers to appropriate types for processing.
    - A loop iterates over the number of stripes defined by `XXH_STRIPE_LEN`, processing data in chunks.
    - Within the loop, it loads data and key vectors from the input and secret pointers respectively.
    - The data and key vectors are XORed to create a combined vector for hashing.
    - The combined vector is then shuffled and multiplied to produce a product vector.
    - The product is added to the accumulator vector, which is then updated with a permutation operation to mix the halves.
- **Output**: The function does not return a value; instead, it updates the accumulator in place with the computed hash values.
- **Functions called**:
    - [`XXH_vec_loadu`](#XXH_vec_loadu)
    - [`XXH_vec_mulo`](#XXH_vec_mulo)


---
### XXH3\_scrambleAcc\_vsx<!-- {{#callable:XXH3_scrambleAcc_vsx}} -->
`XXH3_scrambleAcc_vsx` scrambles an accumulator using a secret key and specific bitwise operations.
- **Inputs**:
    - `acc`: A pointer to the accumulator that will be scrambled, which must be aligned to a 16-byte boundary.
    - `secret`: A pointer to the secret key used for scrambling the accumulator.
- **Control Flow**:
    - The function begins by asserting that the `acc` pointer is aligned to a 16-byte boundary.
    - It casts the `acc` pointer to a `xxh_aliasing_u64x2` type for 64-bit operations and the `secret` pointer to a `const xxh_u8*` type.
    - Constants for scrambling are defined, including two vectors for bit shifts and a prime number vector.
    - A loop iterates over the number of stripes defined by `XXH_STRIPE_LEN`, processing two 64-bit values at a time.
    - Within the loop, the accumulator is first right-shifted by 47 bits and XORed with itself.
    - The result is then XORed with a corresponding value from the `secret` key.
    - The scrambled value is multiplied by a prime number using vectorized multiplication, and the results are combined and stored back in the accumulator.
- **Output**: The function modifies the accumulator in place, resulting in a scrambled state based on the input secret.
- **Functions called**:
    - [`XXH_vec_loadu`](#XXH_vec_loadu)
    - [`XXH_vec_mule`](#XXH_vec_mule)
    - [`XXH_vec_mulo`](#XXH_vec_mulo)


---
### XXH3\_accumulate\_512\_sve<!-- {{#callable:XXH3_accumulate_512_sve}} -->
The `XXH3_accumulate_512_sve` function accumulates values into a 512-bit accumulator using SIMD operations based on the SVE architecture.
- **Inputs**:
    - `acc`: A pointer to the accumulator where the results will be stored, expected to be a 64-bit aligned memory location.
    - `input`: A pointer to the input data that will be processed and accumulated into the accumulator.
    - `secret`: A pointer to a secret key or data that may influence the accumulation process.
- **Control Flow**:
    - The function begins by casting the input pointers to 64-bit integer pointers for processing.
    - It retrieves the number of available elements in the SVE vector register using `svcntd()`.
    - If the element count is 8 or more, it loads the accumulator, applies the `ACCRND` operation, and stores the result back.
    - If the element count is exactly 2, it loads four 64-bit accumulator values, applies the `ACCRND` operation to each, and stores them back.
    - If the element count is less than 2, it loads two 64-bit accumulator values, applies the `ACCRND` operation, and stores them back.
- **Output**: The function does not return a value; instead, it modifies the contents of the accumulator pointed to by `acc` in place.


---
### XXH\_mult32to64\_add64<!-- {{#callable:XXH_mult32to64_add64}} -->
Multiplies two 32-bit unsigned integers and adds the result to a 64-bit accumulator.
- **Inputs**:
    - `lhs`: The left-hand side operand, a 64-bit unsigned integer.
    - `rhs`: The right-hand side operand, a 64-bit unsigned integer.
    - `acc`: The accumulator, a 64-bit unsigned integer to which the result will be added.
- **Control Flow**:
    - The function casts the `lhs` and `rhs` inputs from 64-bit to 32-bit unsigned integers.
    - It calls the [`XXH_mult32to64`](#XXH_mult32to64) function to multiply the two 32-bit integers.
    - The result of the multiplication is then added to the `acc` input.
- **Output**: Returns the sum of the multiplication result and the accumulator as a 64-bit unsigned integer.
- **Functions called**:
    - [`XXH_mult32to64`](#XXH_mult32to64)


---
### XXH3\_scalarRound<!-- {{#callable:XXH3_scalarRound}} -->
`XXH3_scalarRound` performs a hashing operation on a specified lane of input data using a secret key and accumulates the result.
- **Inputs**:
    - `acc`: A pointer to an accumulator array where the results of the hashing operation will be stored.
    - `input`: A pointer to the input data that will be processed.
    - `secret`: A pointer to a secret key used for hashing to enhance security.
    - `lane`: An index indicating which lane of the input data to process.
- **Control Flow**:
    - The function begins by casting the input pointers to appropriate types for processing.
    - It asserts that the provided lane index is within valid bounds and that the accumulator is properly aligned.
    - The function reads a 64-bit value from the input data at the specified lane, and also reads a corresponding value from the secret key.
    - The input value is XORed with the secret value to create a data key.
    - The function then swaps the current lane's value with the adjacent lane's value in the accumulator.
    - Finally, it updates the current lane in the accumulator using a multiplication and addition operation involving the data key.
- **Output**: The function does not return a value; instead, it modifies the accumulator in place with the results of the hashing operation.
- **Functions called**:
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH_mult32to64_add64`](#XXH_mult32to64_add64)


---
### XXH3\_accumulate\_512\_scalar<!-- {{#callable:XXH3_accumulate_512_scalar}} -->
Accumulates hash values into an accumulator using a scalar approach.
- **Inputs**:
    - `acc`: A pointer to the accumulator where the hash values will be accumulated.
    - `input`: A pointer to the input data that will be processed for hashing.
    - `secret`: A pointer to a secret value used in the hashing process to enhance security.
- **Control Flow**:
    - The function begins by declaring a loop index variable `i` of type `size_t`.
    - A preprocessor directive checks for specific compiler and architecture conditions to enable loop unrolling for performance optimization.
    - A for loop iterates from 0 to `XXH_ACC_NB`, calling the [`XXH3_scalarRound`](#XXH3_scalarRound) function on each iteration with the accumulator, input, secret, and the current index `i`.
- **Output**: The function does not return a value; it modifies the accumulator in place based on the input and secret.
- **Functions called**:
    - [`XXH3_scalarRound`](#XXH3_scalarRound)


---
### XXH3\_scalarScrambleRound<!-- {{#callable:XXH3_scalarScrambleRound}} -->
`XXH3_scalarScrambleRound` performs a scrambling operation on a specified lane of an accumulator using a secret key.
- **Inputs**:
    - `acc`: A pointer to the accumulator array where the scrambling will be applied.
    - `secret`: A pointer to the secret key array used for the scrambling operation.
    - `lane`: An index indicating which lane of the accumulator to scramble.
- **Control Flow**:
    - The function begins by casting the `acc` pointer to a `xxh_u64*` type for 64-bit operations.
    - It also casts the `secret` pointer to a `const xxh_u8*` type for byte-level access.
    - Two assertions are made to ensure that the `acc` pointer is properly aligned and that the `lane` index is within valid bounds.
    - The function reads a 64-bit key from the `secret` array based on the specified `lane` index.
    - The corresponding value from the `acc` array is retrieved and subjected to a series of operations: it is first right-shifted, then XORed with the key, and finally multiplied by a prime constant.
    - The modified value is then stored back into the `acc` array at the specified `lane` index.
- **Output**: The function does not return a value; it modifies the accumulator in place.
- **Functions called**:
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH_xorshift64`](#XXH_xorshift64)


---
### XXH3\_scrambleAcc\_scalar<!-- {{#callable:XXH3_scrambleAcc_scalar}} -->
Scrambles the accumulator using a secret key through multiple rounds.
- **Inputs**:
    - `acc`: A pointer to the accumulator that will be scrambled.
    - `secret`: A pointer to the secret key used for scrambling the accumulator.
- **Control Flow**:
    - Initializes a loop variable `i` to iterate from 0 to `XXH_ACC_NB`.
    - Calls the [`XXH3_scalarScrambleRound`](#XXH3_scalarScrambleRound) function for each iteration, passing the accumulator, secret, and the current index `i`.
- **Output**: The function does not return a value; it modifies the accumulator in place.
- **Functions called**:
    - [`XXH3_scalarScrambleRound`](#XXH3_scalarScrambleRound)


---
### XXH3\_initCustomSecret\_scalar<!-- {{#callable:XXH3_initCustomSecret_scalar}} -->
Initializes a custom secret for the XXH3 hash function using a provided seed.
- **Inputs**:
    - `customSecret`: A pointer to a memory location where the custom secret will be stored.
    - `seed64`: A 64-bit unsigned integer used to modify the secret values.
- **Control Flow**:
    - The function begins by defining a pointer `kSecretPtr` to the default secret array `XXH3_kSecret`.
    - It asserts that the default secret size is a multiple of 16 using `XXH_STATIC_ASSERT`.
    - If compiled with GCC or Clang on an aarch64 architecture, a compiler optimization hack is applied to improve performance.
    - The number of rounds for processing is calculated as `XXH_SECRET_DEFAULT_SIZE / 16`.
    - A loop iterates over the number of rounds, reading 64-bit values from `kSecretPtr`, modifying them with `seed64`, and writing the results to `customSecret`.
- **Output**: The function does not return a value; instead, it populates the memory pointed to by `customSecret` with the initialized secret values.
- **Functions called**:
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH_writeLE64`](#XXH_writeLE64)


---
### XXH3\_mix2Accs<!-- {{#callable:XXH3_mix2Accs}} -->
Mixes two accumulator values with secret data using a multiplication and folding operation.
- **Inputs**:
    - `acc`: A pointer to an array of two `xxh_u64` accumulator values that will be mixed.
    - `secret`: A pointer to an array of `xxh_u8` secret data used for mixing with the accumulator values.
- **Control Flow**:
    - The function reads 8 bytes from the `secret` array starting at the base address and another 8 bytes from the same array offset by 8 bytes.
    - It then XORs these values with the corresponding values from the `acc` array.
    - Finally, it calls [`XXH3_mul128_fold64`](#XXH3_mul128_fold64) with the two XORed results to produce the final mixed output.
- **Output**: Returns a `xxh_u64` value that is the result of the multiplication and folding operation on the mixed accumulator values.
- **Functions called**:
    - [`XXH3_mul128_fold64`](#XXH3_mul128_fold64)
    - [`XXH_readLE64`](#XXH_readLE64)


---
### XXH3\_mergeAccs<!-- {{#callable:XXH3_mergeAccs}} -->
Merges four accumulator values with a secret key and a starting value to produce a final hash.
- **Inputs**:
    - `acc`: A pointer to an array of 64-bit unsigned integers representing the accumulators to be merged.
    - `secret`: A pointer to an array of 8-bit unsigned integers representing the secret key used in the mixing process.
    - `start`: A 64-bit unsigned integer that serves as the initial value for the hash computation.
- **Control Flow**:
    - Initializes a variable `result64` with the value of `start`.
    - Iterates four times, each time mixing two accumulator values with a corresponding segment of the secret key using the [`XXH3_mix2Accs`](#XXH3_mix2Accs) function.
    - Includes a compiler guard to prevent autovectorization on specific platforms to optimize performance.
    - After the loop, applies the [`XXH3_avalanche`](#XXH3_avalanche) function to the final result to produce the final hash value.
- **Output**: Returns a 64-bit hash value that is the result of merging the accumulators and applying the avalanche function.
- **Functions called**:
    - [`XXH3_mix2Accs`](#XXH3_mix2Accs)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH3\_hashLong\_64b\_internal<!-- {{#callable:XXH64_hash_t::XXH3_hashLong_64b_internal}} -->
Computes a 64-bit hash of a long input using a secret and specified accumulation and scrambling functions.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `secret`: A pointer to the secret key used for hashing.
    - `secretSize`: The size of the secret key in bytes.
    - `f_acc`: A function pointer for accumulating hash values.
    - `f_scramble`: A function pointer for scrambling the accumulator.
- **Control Flow**:
    - Initializes an accumulator array `acc` with a predefined constant using `XXH3_INIT_ACC`.
    - Calls `XXH3_hashLong_internal_loop` to process the input data, updating the accumulator based on the input, secret, and provided functions.
    - Checks that the size of the secret is sufficient to merge the accumulators.
    - Merges the accumulated values with the secret using [`XXH3_mergeAccs`](#XXH3_mergeAccs), incorporating the length of the input into the final hash.
- **Output**: Returns a 64-bit hash value computed from the input data and the secret.
- **Functions called**:
    - [`XXH3_mergeAccs`](#XXH3_mergeAccs)


---
### XXH3\_hashLong\_64b\_withSecret<!-- {{#callable:XXH64_hash_t::XXH3_hashLong_64b_withSecret}} -->
Computes a 64-bit hash of the input data using a secret key.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value (not used in this function).
    - `secret`: A pointer to the secret key used for hashing.
    - `secretLen`: The length of the secret key in bytes.
- **Control Flow**:
    - Calls the [`XXH3_hashLong_64b_internal`](#XXH64_hash_tXXH3_hashLong_64b_internal) function to perform the actual hashing operation.
    - Passes the input data, its length, the secret key, its length, and two additional functions (`XXH3_accumulate` and `XXH3_scrambleAcc`) as parameters to the internal hashing function.
- **Output**: Returns a 64-bit hash value computed from the input data using the provided secret key.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_hashLong_64b_internal`](#XXH64_hash_tXXH3_hashLong_64b_internal)


---
### XXH3\_hashLong\_64b\_default<!-- {{#callable:XXH3_hashLong_64b_default}} -->
Computes a 64-bit hash of the input data using the default secret and accumulation method.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value for the hash (unused in this function).
    - `secret`: A pointer to a secret key for hashing (unused in this function).
    - `secretLen`: The length of the secret key (unused in this function).
- **Control Flow**:
    - The function begins by ignoring the seed, secret, and secret length parameters.
    - It then calls the [`XXH3_hashLong_64b_internal`](#XXH64_hash_tXXH3_hashLong_64b_internal) function with the input data, its length, a default secret, and predefined accumulation and scrambling functions.
- **Output**: Returns a 64-bit hash value computed from the input data.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_hashLong_64b_internal`](#XXH64_hash_tXXH3_hashLong_64b_internal)


---
### XXH3\_hashLong\_64b\_withSeed\_internal<!-- {{#callable:XXH64_hash_t::XXH3_hashLong_64b_withSeed_internal}} -->
Computes a 64-bit hash of the input data using a seed and custom secret.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed`: A 64-bit seed value used to initialize the hash.
    - `f_acc`: A function pointer for accumulating hash values.
    - `f_scramble`: A function pointer for scrambling the accumulated hash.
    - `f_initSec`: A function pointer for initializing a custom secret.
- **Control Flow**:
    - Checks if the seed is zero; if so, it calls [`XXH3_hashLong_64b_internal`](#XXH64_hash_tXXH3_hashLong_64b_internal) with a default secret.
    - If the seed is non-zero, it initializes a custom secret using the provided `f_initSec` function.
    - Calls [`XXH3_hashLong_64b_internal`](#XXH64_hash_tXXH3_hashLong_64b_internal) with the input data, length, and the initialized secret.
- **Output**: Returns a 64-bit hash value computed from the input data using the specified seed and secret.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_hashLong_64b_internal`](#XXH64_hash_tXXH3_hashLong_64b_internal)


---
### XXH3\_hashLong\_64b\_withSeed<!-- {{#callable:XXH64_hash_t::XXH3_hashLong_64b_withSeed}} -->
Computes a 64-bit hash of the input data using a seed and a custom secret.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed`: A 64-bit seed value used to initialize the hash computation.
    - `secret`: A pointer to a custom secret used in the hashing process.
    - `secretLen`: The length of the custom secret in bytes.
- **Control Flow**:
    - The function begins by ignoring the `secret` and `secretLen` parameters, indicating they are not used in this implementation.
    - It then calls the internal function [`XXH3_hashLong_64b_withSeed_internal`](#XXH64_hash_tXXH3_hashLong_64b_withSeed_internal), passing the input data, its length, the seed, and three function pointers for accumulation, scrambling, and initialization.
- **Output**: Returns a 64-bit hash value computed from the input data using the specified seed.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_hashLong_64b_withSeed_internal`](#XXH64_hash_tXXH3_hashLong_64b_withSeed_internal)


---
### XXH3\_64bits\_internal<!-- {{#callable:XXH64_hash_t::XXH3_64bits_internal}} -->
Calculates a 64-bit hash of the input data using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value used in the hashing process.
    - `secret`: A pointer to the secret key used for hashing.
    - `secretLen`: The length of the secret key.
    - `f_hashLong`: A function pointer to a hashing function for long inputs.
- **Control Flow**:
    - Asserts that the length of the secret key is at least the minimum required size.
    - Checks the length of the input data to determine which hashing function to call based on its size.
    - If the input length is 16 bytes or less, calls [`XXH3_len_0to16_64b`](#XXH3_len_0to16_64b).
    - If the input length is between 17 and 128 bytes, calls [`XXH3_len_17to128_64b`](#XXH3_len_17to128_64b).
    - If the input length is between 129 and 240 bytes, calls [`XXH3_len_129to240_64b`](#XXH3_len_129to240_64b).
    - For input lengths greater than 240 bytes, calls the provided `f_hashLong` function.
- **Output**: Returns a 64-bit hash value computed from the input data, seed, and secret key.
- **Functions called**:
    - [`XXH3_len_0to16_64b`](#XXH3_len_0to16_64b)
    - [`XXH3_len_17to128_64b`](#XXH3_len_17to128_64b)
    - [`XXH3_len_129to240_64b`](#XXH3_len_129to240_64b)


---
### XXH3\_64bits<!-- {{#callable:XXH64_hash_t::XXH3_64bits}} -->
Computes a 64-bit hash of the input data using the XXH3 hashing algorithm.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `length`: The size of the input data in bytes.
- **Control Flow**:
    - Calls the [`XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal) function with the provided input, length, a zero value, a predefined secret key, the size of the secret key, and a default hashing function.
- **Output**: Returns a 64-bit hash value computed from the input data.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal)


---
### XXH3\_64bits\_withSecret<!-- {{#callable:XXH64_hash_t::XXH3_64bits_withSecret}} -->
Computes a 64-bit hash of the input data using a secret key.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `length`: The size of the input data in bytes.
    - `secret`: A pointer to the secret key used for hashing.
    - `secretSize`: The size of the secret key in bytes.
- **Control Flow**:
    - Calls the [`XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal) function with the provided input, length, and secret parameters.
    - Passes a constant value of 0 as the third argument to [`XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal), which may represent a specific hashing mode or option.
    - Uses `XXH3_hashLong_64b_withSecret` as a hashing function within [`XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal).
- **Output**: Returns a 64-bit hash value computed from the input data and the secret key.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal)


---
### XXH3\_64bits\_withSeed<!-- {{#callable:XXH64_hash_t::XXH3_64bits_withSeed}} -->
Computes a 64-bit hash of the input data using a specified seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `length`: The length of the data in bytes.
    - `seed`: A 64-bit hash seed used to initialize the hash computation.
- **Control Flow**:
    - Calls the [`XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal) function to perform the actual hashing.
    - Passes the input data, its length, the seed, a secret key, and the size of the secret key to the internal function.
- **Output**: Returns a 64-bit hash value computed from the input data and the seed.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal)


---
### XXH3\_64bits\_withSecretandSeed<!-- {{#callable:XXH64_hash_t::XXH3_64bits_withSecretandSeed}} -->
Computes a 64-bit hash of the input data using a secret and a seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `length`: The size of the input data in bytes.
    - `secret`: A pointer to the secret key used in the hashing process.
    - `secretSize`: The size of the secret key in bytes.
    - `seed`: A 64-bit seed value used to initialize the hash.
- **Control Flow**:
    - Checks if the length of the input data is less than or equal to `XXH3_MIDSIZE_MAX`.
    - If true, calls [`XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal) to compute the hash using a predefined secret.
    - If false, calls [`XXH3_hashLong_64b_withSecret`](#XXH64_hash_tXXH3_hashLong_64b_withSecret) to compute the hash using the provided secret and length.
- **Output**: Returns a 64-bit hash value computed from the input data, secret, and seed.
- **Functions called**:
    - [`XXH64_hash_t::XXH3_64bits_internal`](#XXH64_hash_tXXH3_64bits_internal)
    - [`XXH64_hash_t::XXH3_hashLong_64b_withSecret`](#XXH64_hash_tXXH3_hashLong_64b_withSecret)


---
### XXH\_alignedMalloc<!-- {{#callable:XXH_alignedMalloc}} -->
Allocates memory aligned to a specified boundary while ensuring proper alignment and storing the offset.
- **Inputs**:
    - `s`: The size in bytes of the memory block to allocate.
    - `align`: The alignment boundary, which must be a power of two between 8 and 128 bytes.
- **Control Flow**:
    - Checks if the alignment is within the valid range (8 to 128) and is a power of two.
    - Validates that the requested size is non-zero and does not cause overflow when added to the alignment.
    - Allocates memory using [`XXH_malloc`](#XXH_malloc) for the requested size plus the alignment.
    - Calculates the offset needed to align the allocated memory pointer.
    - Adjusts the pointer to ensure it is aligned to the specified boundary.
    - Stores the offset in the byte immediately before the aligned pointer.
    - Returns the aligned pointer or NULL if the allocation fails.
- **Output**: Returns a pointer to the aligned memory block, or NULL if the allocation fails.
- **Functions called**:
    - [`XXH_malloc`](#XXH_malloc)


---
### XXH\_alignedFree<!-- {{#callable:XXH_alignedFree}} -->
Frees a previously allocated memory block that was aligned with an offset.
- **Inputs**:
    - `p`: A pointer to the memory block that is to be freed, which may include an offset.
- **Control Flow**:
    - Checks if the input pointer `p` is not NULL to avoid dereferencing a null pointer.
    - Retrieves the offset byte stored just before the pointer `p` to find the original base address.
    - Calculates the original pointer by subtracting the offset from `p`.
    - Calls [`XXH_free`](#XXH_free) to free the original memory block.
- **Output**: This function does not return a value; it performs a memory deallocation operation.
- **Functions called**:
    - [`XXH_free`](#XXH_free)


---
### XXH3\_freeState<!-- {{#callable:XXH_errorcode::XXH3_freeState}} -->
Frees the memory allocated for a given `XXH3_state_t` state pointer.
- **Inputs**:
    - `statePtr`: A pointer to an `XXH3_state_t` structure that holds the state to be freed.
- **Control Flow**:
    - Calls the [`XXH_alignedFree`](#XXH_alignedFree) function to deallocate the memory pointed to by `statePtr`.
    - Returns the constant `XXH_OK` to indicate successful completion of the operation.
- **Output**: Returns an `XXH_errorcode` indicating the result of the operation, which is `XXH_OK` for successful memory deallocation.
- **Functions called**:
    - [`XXH_alignedFree`](#XXH_alignedFree)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_copyState<!-- {{#callable:XXH3_copyState}} -->
Copies the state from one `XXH3_state_t` structure to another.
- **Inputs**:
    - `dst_state`: A pointer to the destination `XXH3_state_t` structure where the state will be copied.
    - `src_state`: A pointer to the source `XXH3_state_t` structure from which the state will be copied.
- **Control Flow**:
    - The function uses [`XXH_memcpy`](#XXH_memcpy) to copy the memory from `src_state` to `dst_state`.
    - The size of the memory copied is determined by the size of the `XXH3_state_t` structure.
- **Output**: This function does not return a value; it modifies the `dst_state` in place.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH3\_reset\_internal<!-- {{#callable:XXH3_reset_internal}} -->
Resets the internal state of an `XXH3_state_t` structure for hash computation.
- **Inputs**:
    - `statePtr`: A pointer to an `XXH3_state_t` structure that holds the state of the hash computation.
    - `seed`: A 64-bit hash seed used to initialize the state.
    - `secret`: A pointer to a secret value used in the hashing process.
    - `secretSize`: The size of the secret value in bytes.
- **Control Flow**:
    - Calculates the starting offset for the `bufferedSize` member of the `XXH3_state_t` structure.
    - Calculates the length of the initialization area from `bufferedSize` to `nbStripesPerBlock`.
    - Asserts that the offset of `nbStripesPerBlock` is greater than the offset of `bufferedSize`.
    - Asserts that the `statePtr` is not NULL to prevent dereferencing a null pointer.
    - Resets the members of the state structure from `bufferedSize` to `nbStripesPerBlock` to zero using `memset`.
    - Initializes the accumulator array `acc` with predefined prime constants.
    - Sets the `seed` member of the state structure to the provided seed value.
    - Determines if the seed is used based on whether it is non-zero.
    - Assigns the provided secret pointer to the `extSecret` member of the state structure.
    - Asserts that the `secretSize` is at least the minimum required size.
    - Calculates and sets the `secretLimit` based on the provided `secretSize`.
- **Output**: The function does not return a value; it modifies the `XXH3_state_t` structure pointed to by `statePtr` to prepare it for a new hashing operation.


---
### XXH3\_64bits\_reset<!-- {{#callable:XXH_errorcode::XXH3_64bits_reset}} -->
Resets the state of a `XXH3_state_t` structure for 64-bit hashing.
- **Inputs**:
    - `statePtr`: A pointer to a `XXH3_state_t` structure that holds the state of the hashing process.
- **Control Flow**:
    - The function first checks if the `statePtr` is NULL, returning `XXH_ERROR` if it is.
    - If `statePtr` is valid, it calls the [`XXH3_reset_internal`](#XXH3_reset_internal) function to reset the state with default parameters.
    - Finally, it returns `XXH_OK` to indicate successful completion.
- **Output**: Returns an `XXH_errorcode` indicating the success or failure of the reset operation.
- **Functions called**:
    - [`XXH3_reset_internal`](#XXH3_reset_internal)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_64bits\_reset\_withSecret<!-- {{#callable:XXH_errorcode::XXH3_64bits_reset_withSecret}} -->
Resets the `XXH3` state with a provided secret and its size.
- **Inputs**:
    - `statePtr`: A pointer to an `XXH3_state_t` structure that holds the state to be reset.
    - `secret`: A pointer to the secret data used for hashing.
    - `secretSize`: The size of the secret data in bytes.
- **Control Flow**:
    - The function first checks if `statePtr` is NULL; if so, it returns an error code `XXH_ERROR`.
    - It calls [`XXH3_reset_internal`](#XXH3_reset_internal) to reset the state with the provided secret and its size.
    - Next, it checks if `secret` is NULL; if so, it returns `XXH_ERROR`.
    - It then checks if `secretSize` is less than the minimum required size (`XXH3_SECRET_SIZE_MIN`); if so, it returns `XXH_ERROR`.
    - If all checks pass, the function returns `XXH_OK` indicating successful reset.
- **Output**: Returns an error code indicating the success or failure of the reset operation.
- **Functions called**:
    - [`XXH3_reset_internal`](#XXH3_reset_internal)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_64bits\_reset\_withSeed<!-- {{#callable:XXH_errorcode::XXH3_64bits_reset_withSeed}} -->
Resets the `XXH3` hash state with a specified seed.
- **Inputs**:
    - `statePtr`: A pointer to the `XXH3_state_t` structure that holds the state of the hash.
    - `seed`: A 64-bit unsigned integer used as a seed for the hash function.
- **Control Flow**:
    - Checks if `statePtr` is NULL and returns an error code if it is.
    - If `seed` is zero, it calls [`XXH3_64bits_reset`](#XXH_errorcodeXXH3_64bits_reset) to reset the state without a custom seed.
    - If the `seed` is different from the current seed in `statePtr` or if `statePtr->extSecret` is not NULL, it initializes the custom secret using `XXH3_initCustomSecret`.
    - Calls [`XXH3_reset_internal`](#XXH3_reset_internal) to reset the internal state with the provided seed and default secret size.
    - Returns a success code `XXH_OK`.
- **Output**: Returns an error code indicating success or failure of the reset operation.
- **Functions called**:
    - [`XXH_errorcode::XXH3_64bits_reset`](#XXH_errorcodeXXH3_64bits_reset)
    - [`XXH3_reset_internal`](#XXH3_reset_internal)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_64bits\_reset\_withSecretandSeed<!-- {{#callable:XXH_errorcode::XXH3_64bits_reset_withSecretandSeed}} -->
Resets the `XXH3` state with a provided secret and seed.
- **Inputs**:
    - `statePtr`: A pointer to the `XXH3_state_t` structure that holds the state of the hash.
    - `secret`: A pointer to the secret data used for hashing.
    - `secretSize`: The size of the secret data in bytes.
    - `seed64`: A 64-bit seed value used to initialize the hash.
- **Control Flow**:
    - Checks if `statePtr` is NULL and returns an error code if true.
    - Checks if `secret` is NULL and returns an error code if true.
    - Checks if `secretSize` is less than the minimum required size and returns an error code if true.
    - Calls [`XXH3_reset_internal`](#XXH3_reset_internal) to reset the state with the provided secret and seed.
    - Sets the `useSeed` flag in the state to 1, indicating that a seed is being used.
    - Returns a success code.
- **Output**: Returns `XXH_OK` on success or an error code if any input validation fails.
- **Functions called**:
    - [`XXH3_reset_internal`](#XXH3_reset_internal)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_consumeStripes<!-- {{#callable:XXH3_consumeStripes}} -->
Processes input stripes and updates the accumulator based on the provided functions.
- **Inputs**:
    - `acc`: A pointer to an accumulator of type `xxh_u64` that will be updated during the processing of stripes.
    - `nbStripesSoFarPtr`: A pointer to a size_t variable that tracks the number of stripes processed so far.
    - `nbStripesPerBlock`: A size_t value indicating the number of stripes that can be processed in one block.
    - `input`: A pointer to the input data of type `xxh_u8` that contains the stripes to be processed.
    - `nbStripes`: A size_t value representing the total number of stripes available for processing.
    - `secret`: A pointer to a secret key of type `xxh_u8` used for scrambling the accumulator.
    - `secretLimit`: A size_t value that specifies the limit for the secret key usage.
    - `f_acc`: A function pointer of type `XXH3_f_accumulate` used to accumulate the stripes into the accumulator.
    - `f_scramble`: A function pointer of type `XXH3_f_scrambleAcc` used to scramble the accumulator.
- **Control Flow**:
    - The function begins by calculating the initial secret based on the number of stripes processed so far.
    - It checks if there are enough stripes to process a full block; if so, it enters a loop to process full blocks.
    - Within the loop, it calls the accumulation function `f_acc` and the scrambling function `f_scramble` for each block.
    - After processing full blocks, it resets the count of stripes processed so far.
    - If there are remaining stripes that do not fill a full block, it processes them in a final call to `f_acc`.
    - Finally, it updates the pointer to the input data and returns it.
- **Output**: Returns a pointer to the end of the processed input data.


---
### XXH3\_64bits\_update<!-- {{#callable:XXH_errorcode::XXH3_64bits_update}} -->
Updates the state of a `XXH3` hash computation with new input data.
- **Inputs**:
    - `state`: A pointer to a `XXH3_state_t` structure that holds the current state of the hash computation.
    - `input`: A pointer to the input data that will be added to the hash computation.
    - `len`: The length of the input data in bytes.
- **Control Flow**:
    - The function calls `XXH3_update`, passing the `state`, `input` cast to `const xxh_u8*`, and `len`.
    - It also provides two additional function pointers: `XXH3_accumulate` and `XXH3_scrambleAcc`.
- **Output**: Returns an `XXH_errorcode` indicating the success or failure of the update operation.
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_digest\_long<!-- {{#callable:XXH3_digest_long}} -->
`XXH3_digest_long` processes buffered data to compute a hash digest using a specified state and secret.
- **Inputs**:
    - `acc`: A pointer to an `XXH64_hash_t` structure where the resulting hash will be accumulated.
    - `state`: A pointer to an `XXH3_state_t` structure containing the current state of the hashing process, including buffered data and accumulated values.
    - `secret`: A pointer to an array of unsigned characters representing the secret used in the hashing algorithm.
- **Control Flow**:
    - The function begins by copying the current accumulated hash from the `state` to `acc` to ensure the state remains unchanged.
    - It checks if the `bufferedSize` in the `state` is greater than or equal to `XXH_STRIPE_LEN` to determine how to process the buffered data.
    - If there are enough buffered bytes, it calculates the number of complete stripes and calls [`XXH3_consumeStripes`](#XXH3_consumeStripes) to process these stripes, updating the number of stripes consumed.
    - If there are not enough buffered bytes, it copies the necessary bytes into a temporary buffer to form a complete stripe.
    - Finally, it processes the last stripe using `XXH3_accumulate_512`, which updates the accumulated hash with the last stripe of data.
- **Output**: The function does not return a value; instead, it updates the `acc` pointer with the computed hash digest based on the processed input data.
- **Functions called**:
    - [`XXH_memcpy`](#XXH_memcpy)
    - [`XXH3_consumeStripes`](#XXH3_consumeStripes)


---
### XXH3\_64bits\_digest<!-- {{#callable:XXH64_hash_t::XXH3_64bits_digest}} -->
Calculates the 64-bit hash digest of a given state using the XXH3 hashing algorithm.
- **Inputs**:
    - `state`: A pointer to a `XXH3_state_t` structure that contains the state of the hashing process, including the input buffer, total length, secret keys, and other parameters.
- **Control Flow**:
    - Checks if the `extSecret` is NULL; if so, it uses `customSecret` from the state.
    - If `totalLen` is greater than `XXH3_MIDSIZE_MAX`, it initializes an accumulator array and calls [`XXH3_digest_long`](#XXH3_digest_long) to process the input, then merges the results using [`XXH3_mergeAccs`](#XXH3_mergeAccs).
    - If `totalLen` is less than or equal to `XXH3_MIDSIZE_MAX`, it checks if a seed is used; if so, it calls [`XXH3_64bits_withSeed`](#XXH64_hash_tXXH3_64bits_withSeed) to compute the hash with the provided seed.
    - If no seed is used, it calls [`XXH3_64bits_withSecret`](#XXH64_hash_tXXH3_64bits_withSecret) to compute the hash using the secret key.
- **Output**: Returns a 64-bit hash value of type `XXH64_hash_t`, which represents the computed hash digest of the input data based on the state.
- **Functions called**:
    - [`XXH3_digest_long`](#XXH3_digest_long)
    - [`XXH3_mergeAccs`](#XXH3_mergeAccs)
    - [`XXH64_hash_t::XXH3_64bits_withSeed`](#XXH64_hash_tXXH3_64bits_withSeed)
    - [`XXH64_hash_t::XXH3_64bits_withSecret`](#XXH64_hash_tXXH3_64bits_withSecret)


---
### XXH3\_len\_1to3\_128b<!-- {{#callable:XXH3_len_1to3_128b}} -->
Computes a 128-bit hash for input strings of length 1 to 3 using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input byte array to be hashed, which must not be NULL.
    - `len`: The length of the input byte array, which must be between 1 and 3.
    - `secret`: A pointer to a secret key byte array used for hashing, which must not be NULL.
    - `seed`: A 64-bit seed value used to modify the hash output.
- **Control Flow**:
    - The function begins by asserting that the input and secret pointers are not NULL and that the length is between 1 and 3.
    - Depending on the length of the input, it constructs a combined value from the input bytes and the length.
    - It then computes a high and low combined hash value using bitwise operations and the secret key.
    - The final hash values are processed through an avalanche function to ensure uniform distribution.
    - The function returns a `XXH128_hash_t` structure containing the computed 128-bit hash.
- **Output**: Returns a `XXH128_hash_t` structure containing the 128-bit hash value derived from the input, secret, and seed.
- **Functions called**:
    - [`XXH_swap32`](#XXH_swap32)
    - [`XXH_readLE32`](#XXH_readLE32)
    - [`XXH64_avalanche`](#XXH64_avalanche)


---
### XXH3\_len\_4to8\_128b<!-- {{#callable:XXH3_len_4to8_128b}} -->
Computes a 128-bit hash for input data of length between 4 and 8 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data of length between 4 and 8 bytes.
    - `len`: The length of the input data, which must be between 4 and 8.
    - `secret`: A pointer to a secret key used in the hashing process.
    - `seed`: A 64-bit seed value that is used to modify the hash computation.
- **Control Flow**:
    - The function begins by asserting that the input and secret pointers are not NULL and that the length is between 4 and 8.
    - The seed is modified by XORing it with a shifted version of itself.
    - The function reads the first and last 4 bytes of the input to create a 64-bit integer representation.
    - A bitflip value is computed using the secret key and the modified seed.
    - The keyed input is generated by XORing the input with the bitflip value.
    - The function then computes a 128-bit multiplication using the keyed input and a prime value adjusted by the length.
    - Various transformations and shifts are applied to the resulting hash values to ensure randomness and distribution.
    - Finally, the function returns the computed 128-bit hash.
- **Output**: Returns a `XXH128_hash_t` structure containing the computed 128-bit hash value.
- **Functions called**:
    - [`XXH_swap32`](#XXH_swap32)
    - [`XXH_readLE32`](#XXH_readLE32)
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH_mult64to128`](#XXH_mult64to128)
    - [`XXH_xorshift64`](#XXH_xorshift64)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH3\_len\_9to16\_128b<!-- {{#callable:XXH3_len_9to16_128b}} -->
Computes a 128-bit hash for input data of length between 9 and 16 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, which must not be NULL.
    - `len`: The length of the input data, which must be between 9 and 16 bytes.
    - `secret`: A pointer to the secret key used in the hashing process, which must not be NULL.
    - `seed`: A 64-bit seed value used to influence the hash output.
- **Control Flow**:
    - The function begins by asserting that the input and secret pointers are not NULL and that the length is within the specified range.
    - It calculates two 64-bit values, `bitflipl` and `bitfliph`, derived from the secret key and the seed.
    - The function reads the first and last 8 bytes of the input data to create `input_lo` and `input_hi`.
    - A 128-bit intermediate hash value `m128` is computed using a multiplication function with the modified input values.
    - The length of the input is mixed into the `m128` value to ensure it affects the final hash.
    - Depending on whether the architecture is 32-bit or 64-bit, the function performs different calculations to update the high part of `m128` using `input_hi`.
    - The high and low parts of `m128` are then mixed together using a swap operation.
    - Finally, the function multiplies `m128` by a prime constant and applies an avalanche function to both parts of the resulting hash before returning it.
- **Output**: Returns a `XXH128_hash_t` structure containing the computed 128-bit hash value.
- **Functions called**:
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH_mult64to128`](#XXH_mult64to128)
    - [`XXH_mult32to64`](#XXH_mult32to64)
    - [`XXH_swap64`](#XXH_swap64)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH3\_len\_0to16\_128b<!-- {{#callable:XXH3_len_0to16_128b}} -->
Computes a 128-bit hash for input data of length 0 to 16 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, which can be up to 16 bytes long.
    - `len`: The length of the input data in bytes, which must be less than or equal to 16.
    - `secret`: A pointer to a secret key used in the hashing process, which is expected to be at least 128 bits long.
    - `seed`: A 64-bit seed value used to initialize the hash computation.
- **Control Flow**:
    - The function first asserts that the length of the input does not exceed 16 bytes.
    - If the length is greater than 8, it calls [`XXH3_len_9to16_128b`](#XXH3_len_9to16_128b) to handle the hashing for lengths 9 to 16.
    - If the length is between 4 and 8, it calls [`XXH3_len_4to8_128b`](#XXH3_len_4to8_128b) for those lengths.
    - If the length is between 1 and 3, it calls [`XXH3_len_1to3_128b`](#XXH3_len_1to3_128b) for those lengths.
    - If the length is 0, it computes a hash using the seed and specific values derived from the `secret`.
- **Output**: Returns a `XXH128_hash_t` structure containing the computed 128-bit hash value.
- **Functions called**:
    - [`XXH3_len_9to16_128b`](#XXH3_len_9to16_128b)
    - [`XXH3_len_4to8_128b`](#XXH3_len_4to8_128b)
    - [`XXH3_len_1to3_128b`](#XXH3_len_1to3_128b)
    - [`XXH_readLE64`](#XXH_readLE64)
    - [`XXH64_avalanche`](#XXH64_avalanche)


---
### XXH128\_mix32B<!-- {{#callable:XXH128_hash_t::XXH128_mix32B}} -->
Mixes two 32-byte inputs with a hash accumulator and a secret key to produce a new hash value.
- **Inputs**:
    - `acc`: The current hash accumulator of type `XXH128_hash_t` which will be updated.
    - `input_1`: A pointer to the first 32-byte input data of type `xxh_u8`.
    - `input_2`: A pointer to the second 32-byte input data of type `xxh_u8`.
    - `secret`: A pointer to a secret key used for mixing, also of type `xxh_u8`.
    - `seed`: A seed value of type `XXH64_hash_t` used in the mixing process.
- **Control Flow**:
    - The function begins by mixing the first input (`input_1`) with the secret key and seed using [`XXH3_mix16B`](#XXH3_mix16B), updating the `low64` part of the accumulator.
    - Next, it reads 64 bits from `input_2`, adds it to the `low64` part of the accumulator, and performs an XOR operation with the result.
    - Then, it mixes the second input (`input_2`) with a different part of the secret key and seed, updating the `high64` part of the accumulator.
    - Finally, it reads 64 bits from `input_1`, adds it to the `high64` part of the accumulator, and performs another XOR operation with the result.
- **Output**: Returns the updated hash accumulator of type `XXH128_hash_t` after mixing the inputs.
- **Functions called**:
    - [`XXH3_mix16B`](#XXH3_mix16B)
    - [`XXH_readLE64`](#XXH_readLE64)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_len\_17to128\_128b<!-- {{#callable:XXH3_len_17to128_128b}} -->
Computes a 128-bit hash for input data of length between 17 and 128 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, which must be between 17 and 128 bytes in length.
    - `len`: The length of the input data in bytes, which must be greater than 16 and less than or equal to 128.
    - `secret`: A pointer to the secret key used in the hashing process, which must be at least XXH3_SECRET_SIZE_MIN bytes long.
    - `secretSize`: The size of the secret key in bytes, which must be at least XXH3_SECRET_SIZE_MIN.
    - `seed`: A 64-bit seed value used to influence the hash output.
- **Control Flow**:
    - The function begins by asserting that the secret size is at least XXH3_SECRET_SIZE_MIN and that the input length is between 17 and 128 bytes.
    - An accumulator `acc` is initialized based on the input length multiplied by a prime constant.
    - Depending on the length of the input, the function processes the input in chunks of 32 bytes or less, mixing the accumulator with portions of the input and secret using the [`XXH128_mix32B`](#XXH128_hash_tXXH128_mix32B) function.
    - After processing the input, a final hash value `h128` is computed by combining the accumulator's low and high parts, applying additional mixing and avalanche functions to ensure a good distribution of hash values.
    - The final 128-bit hash value is returned.
- **Output**: Returns a `XXH128_hash_t` structure containing the computed 128-bit hash value, represented by two 64-bit integers.
- **Functions called**:
    - [`XXH128_hash_t::XXH128_mix32B`](#XXH128_hash_tXXH128_mix32B)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH3\_len\_129to240\_128b<!-- {{#callable:XXH3_len_129to240_128b}} -->
Computes a 128-bit hash for input data of length between 129 and 240 bytes using a secret key and a seed.
- **Inputs**:
    - `input`: A pointer to the input data to be hashed, which must be between 129 and 240 bytes in length.
    - `len`: The length of the input data, which must be greater than 128 and less than or equal to XXH3_MIDSIZE_MAX.
    - `secret`: A pointer to the secret key used in the hashing process, which must be at least XXH3_SECRET_SIZE_MIN bytes long.
    - `secretSize`: The size of the secret key, which is asserted to be at least XXH3_SECRET_SIZE_MIN.
    - `seed`: A 64-bit seed value used to influence the hash output.
- **Control Flow**:
    - The function begins by asserting that the secret size is valid and that the input length is within the specified range.
    - An accumulator `acc` is initialized based on the input length multiplied by a prime constant.
    - A loop iterates from 32 to 160 in steps of 32, mixing 32 bytes of input and secret data into the accumulator using the [`XXH128_mix32B`](#XXH128_hash_tXXH128_mix32B) function.
    - Another loop processes the remaining input data from 160 to the specified length, again mixing 32 bytes at a time.
    - The last 32 bytes of the input are mixed into the accumulator, using a modified secret offset.
    - The final hash value is computed by combining the low and high parts of the accumulator, applying the [`XXH3_avalanche`](#XXH3_avalanche) function to both parts for finalization.
    - The computed 128-bit hash is returned.
- **Output**: Returns a `XXH128_hash_t` structure containing the computed 128-bit hash value, which is derived from the mixed accumulator values.
- **Functions called**:
    - [`XXH128_hash_t::XXH128_mix32B`](#XXH128_hash_tXXH128_mix32B)
    - [`XXH3_avalanche`](#XXH3_avalanche)


---
### XXH3\_hashLong\_128b\_internal<!-- {{#callable:XXH128_hash_t::XXH3_hashLong_128b_internal}} -->
Computes a 128-bit hash from a given input using a secret and specified accumulation and scrambling functions.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `secret`: A pointer to a secret key used in the hashing process.
    - `secretSize`: The size of the secret key in bytes.
    - `f_acc`: A function pointer for accumulating hash values.
    - `f_scramble`: A function pointer for scrambling the accumulated hash values.
- **Control Flow**:
    - Initializes an array `acc` to hold intermediate hash values.
    - Calls `XXH3_hashLong_internal_loop` to process the input data and update the `acc` array using the provided secret and functions.
    - Checks that the size of the secret is sufficient for merging the accumulated values.
    - Merges the accumulated values in `acc` with parts of the secret to produce two 64-bit hash components.
    - Returns a `XXH128_hash_t` structure containing the final 128-bit hash.
- **Output**: Returns a `XXH128_hash_t` structure containing the computed 128-bit hash, with `low64` and `high64` representing the two halves of the hash.
- **Functions called**:
    - [`XXH3_mergeAccs`](#XXH3_mergeAccs)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_hashLong\_128b\_default<!-- {{#callable:XXH3_hashLong_128b_default}} -->
Computes a 128-bit hash of the input data using the default secret.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value for hash computation, which is not used in this implementation.
    - `secret`: A pointer to a secret key used for hashing, which is not used in this implementation.
    - `secretLen`: The length of the secret key, which is not used in this implementation.
- **Control Flow**:
    - The function begins by ignoring the seed64, secret, and secretLen parameters, indicating they are not utilized.
    - It then calls the [`XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal) function with the input data, its length, a default secret, and the size of that secret.
    - The [`XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal) function is responsible for the actual hashing process.
- **Output**: Returns a `XXH128_hash_t` type value representing the computed 128-bit hash of the input data.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal)


---
### XXH3\_hashLong\_128b\_withSecret<!-- {{#callable:XXH128_hash_t::XXH3_hashLong_128b_withSecret}} -->
Computes a 128-bit hash of the input data using a secret key.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value (not used in this function).
    - `secret`: A pointer to the secret key used for hashing.
    - `secretLen`: The length of the secret key in bytes.
- **Control Flow**:
    - Calls the [`XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal) function to perform the actual hashing operation.
    - Passes the input data, its length, the secret key, and its length to the internal hashing function along with two specific functions for accumulation and scrambling.
- **Output**: Returns a `XXH128_hash_t` type value representing the computed 128-bit hash.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_hashLong\_128b\_withSeed\_internal<!-- {{#callable:XXH128_hash_t::XXH3_hashLong_128b_withSeed_internal}} -->
Computes a 128-bit hash of the input data using a seed and custom secret initialization.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value used for hash initialization.
    - `f_acc`: A function pointer for accumulating hash values.
    - `f_scramble`: A function pointer for scrambling the accumulated hash.
    - `f_initSec`: A function pointer for initializing a custom secret based on the seed.
- **Control Flow**:
    - Checks if the seed64 is zero.
    - If seed64 is zero, calls [`XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal) with a default secret.
    - If seed64 is non-zero, initializes a custom secret using `f_initSec` and the seed.
    - Calls [`XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal) with the custom secret and returns the result.
- **Output**: Returns a `XXH128_hash_t` value representing the computed 128-bit hash of the input data.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_hashLong_128b_internal`](#XXH128_hash_tXXH3_hashLong_128b_internal)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_hashLong\_128b\_withSeed<!-- {{#callable:XXH128_hash_t::XXH3_hashLong_128b_withSeed}} -->
Computes a 128-bit hash of the input data using a specified seed and a secret.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value used to influence the hash result.
    - `secret`: A pointer to a secret value that is not used in this implementation.
    - `secretLen`: The length of the secret value, which is also not used in this implementation.
- **Control Flow**:
    - The function begins by ignoring the `secret` and `secretLen` parameters, indicating they are not utilized in the hashing process.
    - It then calls the internal function [`XXH3_hashLong_128b_withSeed_internal`](#XXH128_hash_tXXH3_hashLong_128b_withSeed_internal), passing the input data, its length, the seed, and three additional function pointers for accumulation, scrambling, and initialization.
- **Output**: Returns a `XXH128_hash_t` structure containing the computed 128-bit hash of the input data.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_hashLong_128b_withSeed_internal`](#XXH128_hash_tXXH3_hashLong_128b_withSeed_internal)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_128bits\_internal<!-- {{#callable:XXH128_hash_t::XXH3_128bits_internal}} -->
`XXH3_128bits_internal` computes a 128-bit hash of the input data using a specified secret and seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed64`: A 64-bit seed value used in the hashing process.
    - `secret`: A pointer to a secret key used to enhance the hash function.
    - `secretLen`: The length of the secret key in bytes.
    - `f_hl128`: A function pointer to a hashing function for long inputs.
- **Control Flow**:
    - The function asserts that the length of the secret is at least `XXH3_SECRET_SIZE_MIN`.
    - If the input length is 16 bytes or less, it calls [`XXH3_len_0to16_128b`](#XXH3_len_0to16_128b) to compute the hash.
    - If the input length is between 17 and 128 bytes, it calls [`XXH3_len_17to128_128b`](#XXH3_len_17to128_128b) for hashing.
    - If the input length is between 129 and `XXH3_MIDSIZE_MAX`, it calls [`XXH3_len_129to240_128b`](#XXH3_len_129to240_128b).
    - For inputs longer than `XXH3_MIDSIZE_MAX`, it invokes the provided function pointer `f_hl128` to compute the hash.
- **Output**: The function returns a `XXH128_hash_t` value representing the computed 128-bit hash of the input data.
- **Functions called**:
    - [`XXH3_len_0to16_128b`](#XXH3_len_0to16_128b)
    - [`XXH3_len_17to128_128b`](#XXH3_len_17to128_128b)
    - [`XXH3_len_129to240_128b`](#XXH3_len_129to240_128b)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_128bits<!-- {{#callable:XXH128_hash_t::XXH3_128bits}} -->
Computes a 128-bit hash of the input data using the XXH3 hashing algorithm.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the data in bytes.
- **Control Flow**:
    - Calls the [`XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal) function with the provided input and length.
    - Passes additional parameters including a secret key and a hashing function to the internal function.
- **Output**: Returns a `XXH128_hash_t` type which contains the computed 128-bit hash value.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_128bits\_withSecret<!-- {{#callable:XXH128_hash_t::XXH3_128bits_withSecret}} -->
Computes a 128-bit hash of the input data using a secret key.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `secret`: A pointer to the secret key used for hashing.
    - `secretSize`: The size of the secret key in bytes.
- **Control Flow**:
    - Calls the [`XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal) function to perform the hashing operation.
    - Passes the input data, its length, a null value for the seed, the secret key, its size, and a specific hashing function as parameters.
- **Output**: Returns a `XXH128_hash_t` type which contains the computed 128-bit hash value.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_128bits\_withSeed<!-- {{#callable:XXH128_hash_t::XXH3_128bits_withSeed}} -->
Computes a 128-bit hash of the input data using a specified seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed`: A 64-bit seed value used to influence the hash output.
- **Control Flow**:
    - Calls the [`XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal) function with the provided input, length, and seed.
    - Passes additional parameters including a secret key and its size to the internal hashing function.
- **Output**: Returns a `XXH128_hash_t` type value representing the computed 128-bit hash.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_128bits\_withSecretandSeed<!-- {{#callable:XXH128_hash_t::XXH3_128bits_withSecretandSeed}} -->
Computes a 128-bit hash of the input data using a secret and a seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `secret`: A pointer to the secret key used in the hashing process.
    - `secretSize`: The size of the secret key in bytes.
    - `seed`: A 64-bit seed value used to initialize the hash function.
- **Control Flow**:
    - Checks if the length of the input data is less than or equal to `XXH3_MIDSIZE_MAX`.
    - If true, calls [`XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal) with the input, length, seed, a predefined secret, and its size.
    - If false, calls [`XXH3_hashLong_128b_withSecret`](#XXH128_hash_tXXH3_hashLong_128b_withSecret) with the input, length, seed, secret, and secret size.
- **Output**: Returns a `XXH128_hash_t` type value representing the computed 128-bit hash of the input data.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_128bits_internal`](#XXH128_hash_tXXH3_128bits_internal)
    - [`XXH128_hash_t::XXH3_hashLong_128b_withSecret`](#XXH128_hash_tXXH3_hashLong_128b_withSecret)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH128<!-- {{#callable:XXH128_hash_t::XXH128}} -->
Computes a 128-bit hash of the input data using a specified seed.
- **Inputs**:
    - `input`: A pointer to the data to be hashed.
    - `len`: The length of the input data in bytes.
    - `seed`: A 64-bit hash seed used to initialize the hash computation.
- **Control Flow**:
    - The function directly calls [`XXH3_128bits_withSeed`](#XXH128_hash_tXXH3_128bits_withSeed) with the provided input, length, and seed.
    - No additional logic or error handling is performed within this function.
- **Output**: Returns a 128-bit hash value computed from the input data and the seed.
- **Functions called**:
    - [`XXH128_hash_t::XXH3_128bits_withSeed`](#XXH128_hash_tXXH3_128bits_withSeed)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_128bits\_reset<!-- {{#callable:XXH_errorcode::XXH3_128bits_reset}} -->
Resets the state of a `XXH3_state_t` structure for 128-bit hashing.
- **Inputs**:
    - `statePtr`: A pointer to an `XXH3_state_t` structure that holds the state of the hashing process.
- **Control Flow**:
    - The function calls [`XXH3_64bits_reset`](#XXH_errorcodeXXH3_64bits_reset) with the provided `statePtr` as an argument.
    - The return value of [`XXH3_64bits_reset`](#XXH_errorcodeXXH3_64bits_reset) is returned as the output of `XXH3_128bits_reset`.
- **Output**: Returns an `XXH_errorcode` indicating the success or failure of the reset operation.
- **Functions called**:
    - [`XXH_errorcode::XXH3_64bits_reset`](#XXH_errorcodeXXH3_64bits_reset)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_128bits\_reset\_withSecret<!-- {{#callable:XXH_errorcode::XXH3_128bits_reset_withSecret}} -->
Resets the `XXH3` state with a provided secret and its size.
- **Inputs**:
    - `statePtr`: A pointer to the `XXH3_state_t` structure that holds the state of the hash.
    - `secret`: A pointer to the secret data used for hashing.
    - `secretSize`: The size of the secret data in bytes.
- **Control Flow**:
    - The function calls [`XXH3_64bits_reset_withSecret`](#XXH_errorcodeXXH3_64bits_reset_withSecret) with the same parameters.
    - It does not contain any additional logic or error handling.
- **Output**: Returns an error code of type `XXH_errorcode` indicating the success or failure of the reset operation.
- **Functions called**:
    - [`XXH_errorcode::XXH3_64bits_reset_withSecret`](#XXH_errorcodeXXH3_64bits_reset_withSecret)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_128bits\_reset\_withSeed<!-- {{#callable:XXH_errorcode::XXH3_128bits_reset_withSeed}} -->
Resets the `XXH3` state with a given seed for 128-bit hashing.
- **Inputs**:
    - `statePtr`: A pointer to an `XXH3_state_t` structure that holds the state of the hashing process.
    - `seed`: A 64-bit unsigned integer used as a seed for the hash function.
- **Control Flow**:
    - The function calls [`XXH3_64bits_reset_withSeed`](#XXH_errorcodeXXH3_64bits_reset_withSeed), passing the `statePtr` and `seed` as arguments.
    - The return value of [`XXH3_64bits_reset_withSeed`](#XXH_errorcodeXXH3_64bits_reset_withSeed) is returned directly as the output of this function.
- **Output**: Returns an `XXH_errorcode` indicating the success or failure of the reset operation.
- **Functions called**:
    - [`XXH_errorcode::XXH3_64bits_reset_withSeed`](#XXH_errorcodeXXH3_64bits_reset_withSeed)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_128bits\_reset\_withSecretandSeed<!-- {{#callable:XXH_errorcode::XXH3_128bits_reset_withSecretandSeed}} -->
Resets the `XXH3` state with a secret and a seed, returning an error code.
- **Inputs**:
    - `statePtr`: A pointer to the `XXH3_state_t` structure that holds the state of the hash.
    - `secret`: A pointer to the secret data used for hashing.
    - `secretSize`: The size of the secret data in bytes.
    - `seed`: A 64-bit hash seed used to initialize the state.
- **Control Flow**:
    - The function calls [`XXH3_64bits_reset_withSecretandSeed`](#XXH_errorcodeXXH3_64bits_reset_withSecretandSeed) with the provided parameters.
    - It does not contain any additional logic or error handling beyond the function call.
- **Output**: Returns an `XXH_errorcode` indicating the success or failure of the reset operation.
- **Functions called**:
    - [`XXH_errorcode::XXH3_64bits_reset_withSecretandSeed`](#XXH_errorcodeXXH3_64bits_reset_withSecretandSeed)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_128bits\_update<!-- {{#callable:XXH_errorcode::XXH3_128bits_update}} -->
Updates the `XXH3_state_t` state with the provided input data for the XXH3 hash algorithm.
- **Inputs**:
    - `state`: A pointer to an `XXH3_state_t` structure that holds the current state of the hash computation.
    - `input`: A pointer to the input data that will be processed and included in the hash computation.
    - `len`: The length of the input data in bytes.
- **Control Flow**:
    - The function calls [`XXH3_64bits_update`](#XXH_errorcodeXXH3_64bits_update), passing the same `state`, `input`, and `len` parameters.
    - The return value of [`XXH3_64bits_update`](#XXH_errorcodeXXH3_64bits_update) is returned directly as the output of `XXH3_128bits_update`.
- **Output**: Returns an `XXH_errorcode` indicating the success or failure of the update operation.
- **Functions called**:
    - [`XXH_errorcode::XXH3_64bits_update`](#XXH_errorcodeXXH3_64bits_update)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_128bits\_digest<!-- {{#callable:XXH128_hash_t::XXH3_128bits_digest}} -->
Calculates a 128-bit hash digest from the provided `XXH3_state_t` structure.
- **Inputs**:
    - `state`: A pointer to an `XXH3_state_t` structure that contains the state of the hashing process, including the total length of data, secret keys, and buffer.
- **Control Flow**:
    - Checks if the `extSecret` is NULL; if so, it uses `customSecret` from the state.
    - If the total length of data (`totalLen`) is greater than `XXH3_MIDSIZE_MAX`, it initializes an accumulator array and calls [`XXH3_digest_long`](#XXH3_digest_long) to process the data.
    - It asserts that the secret limit is sufficient for merging the accumulated results.
    - Merges the accumulated results into a `XXH128_hash_t` structure using [`XXH3_mergeAccs`](#XXH3_mergeAccs) for both low and high 64-bit parts.
    - If the total length is less than or equal to `XXH3_MIDSIZE_MAX`, it checks if a seed is used and calls either [`XXH3_128bits_withSeed`](#XXH128_hash_tXXH3_128bits_withSeed) or [`XXH3_128bits_withSecret`](#XXH128_hash_tXXH3_128bits_withSecret) to compute the hash.
- **Output**: Returns a `XXH128_hash_t` structure containing the 128-bit hash digest of the input data.
- **Functions called**:
    - [`XXH3_digest_long`](#XXH3_digest_long)
    - [`XXH3_mergeAccs`](#XXH3_mergeAccs)
    - [`XXH128_hash_t::XXH3_128bits_withSeed`](#XXH128_hash_tXXH3_128bits_withSeed)
    - [`XXH128_hash_t::XXH3_128bits_withSecret`](#XXH128_hash_tXXH3_128bits_withSecret)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH128\_isEqual<!-- {{#callable:XXH128_isEqual}} -->
Compares two `XXH128_hash_t` hashes for equality.
- **Inputs**:
    - `h1`: The first `XXH128_hash_t` hash to compare.
    - `h2`: The second `XXH128_hash_t` hash to compare.
- **Control Flow**:
    - The function uses `memcmp` to compare the memory contents of the two hashes.
    - It checks if the size of the hashes is equal to the size of `h1`.
    - The result of `memcmp` is negated to return 1 if the hashes are equal and 0 if they are not.
- **Output**: Returns 1 if the two hashes are equal, otherwise returns 0.


---
### XXH128\_cmp<!-- {{#callable:XXH128_cmp}} -->
Compares two `XXH128_hash_t` structures and returns an integer indicating their relative order.
- **Inputs**:
    - `h128_1`: A pointer to the first `XXH128_hash_t` structure to compare.
    - `h128_2`: A pointer to the second `XXH128_hash_t` structure to compare.
- **Control Flow**:
    - Dereferences the pointers `h128_1` and `h128_2` to obtain the `XXH128_hash_t` structures `h1` and `h2`.
    - Compares the `high64` fields of `h1` and `h2` to determine their order, storing the result in `hcmp`.
    - If `hcmp` is non-zero, it returns `hcmp`, indicating that one hash is greater than the other.
    - If `hcmp` is zero, it compares the `low64` fields of `h1` and `h2` and returns the result of that comparison.
- **Output**: Returns an integer: a negative value if `h128_1` is less than `h128_2`, zero if they are equal, and a positive value if `h128_1` is greater than `h128_2`.


---
### XXH128\_canonicalFromHash<!-- {{#callable:XXH128_canonicalFromHash}} -->
Converts a `XXH128_hash_t` hash into its canonical form stored in `XXH128_canonical_t`.
- **Inputs**:
    - `dst`: A pointer to a `XXH128_canonical_t` structure where the canonical form of the hash will be stored.
    - `hash`: A `XXH128_hash_t` structure containing the hash to be converted.
- **Control Flow**:
    - The function asserts that the size of `XXH128_canonical_t` is equal to the size of `XXH128_hash_t` using a static assertion.
    - If the CPU architecture is little-endian, it swaps the byte order of the `high64` and `low64` fields of the `hash` to ensure correct representation.
    - The function then copies the `high64` field of the `hash` into the destination structure `dst`.
    - Finally, it copies the `low64` field of the `hash` into the `dst` structure, right after the `high64` field.
- **Output**: The function does not return a value; instead, it populates the `dst` structure with the canonical representation of the provided hash.
- **Functions called**:
    - [`XXH_swap64`](#XXH_swap64)
    - [`XXH_memcpy`](#XXH_memcpy)


---
### XXH128\_hashFromCanonical<!-- {{#callable:XXH128_hash_t::XXH128_hashFromCanonical}} -->
Calculates a 128-bit hash from a canonical representation of the hash input.
- **Inputs**:
    - `src`: A pointer to a `XXH128_canonical_t` structure that contains the canonical representation of the hash input.
- **Control Flow**:
    - The function initializes a `XXH128_hash_t` structure named `h` to store the resulting hash.
    - It reads the first 8 bytes from the `src` pointer using [`XXH_readBE64`](#XXH_readBE64) and assigns it to `h.high64`.
    - It reads the next 8 bytes from the `src->digest` (offset by 8 bytes) using [`XXH_readBE64`](#XXH_readBE64) and assigns it to `h.low64`.
    - Finally, the function returns the populated `h` structure.
- **Output**: Returns a `XXH128_hash_t` structure containing the high and low 64 bits of the computed hash.
- **Functions called**:
    - [`XXH_readBE64`](#XXH_readBE64)
- **See also**: [`XXH128_hash_t`](#XXH128_hash_t)  (Data Structure)


---
### XXH3\_combine16<!-- {{#callable:XXH3_combine16}} -->
The `XXH3_combine16` function combines a 128-bit hash with an existing 128-bit hash stored in a destination buffer.
- **Inputs**:
    - `dst`: A pointer to a destination buffer where the combined hash will be stored.
    - `h128`: A `XXH128_hash_t` structure containing two 64-bit hash values (low64 and high64) to be combined with the existing hash in the destination buffer.
- **Control Flow**:
    - The function first reads the current 64-bit value from the destination buffer using [`XXH_readLE64`](#XXH_readLE64).
    - It then performs a bitwise XOR operation with the `low64` part of the `h128` hash and writes the result back to the destination buffer using [`XXH_writeLE64`](#XXH_writeLE64).
    - Next, it reads the next 64-bit value (the high part) from the destination buffer, applies a bitwise XOR with the `high64` part of the `h128` hash, and writes the result back to the appropriate location in the destination buffer.
- **Output**: The function does not return a value; instead, it modifies the contents of the destination buffer `dst` to reflect the combined hash.
- **Functions called**:
    - [`XXH_writeLE64`](#XXH_writeLE64)
    - [`XXH_readLE64`](#XXH_readLE64)


---
### XXH3\_generateSecret<!-- {{#callable:XXH_errorcode::XXH3_generateSecret}} -->
Generates a secret buffer by filling it with a custom seed or a default seed, ensuring the buffer meets size requirements.
- **Inputs**:
    - `secretBuffer`: A pointer to the buffer where the generated secret will be stored.
    - `secretSize`: The size of the `secretBuffer`, which must be at least `XXH3_SECRET_SIZE_MIN`.
    - `customSeed`: A pointer to the custom seed used to generate the secret; if NULL or of size 0, a default seed is used.
    - `customSeedSize`: The size of the `customSeed` buffer.
- **Control Flow**:
    - The function begins by checking if `secretBuffer` is NULL and if `secretSize` is less than the minimum required size, returning an error if either condition fails.
    - If `customSeedSize` is 0, it assigns a default seed and its size to `customSeed` and `customSeedSize` respectively.
    - It then checks if `customSeed` is NULL, returning an error if it is.
    - The function fills `secretBuffer` by copying `customSeed` into it repeatedly until the entire buffer is filled.
    - Next, it calculates the number of 16-byte segments in `secretSize` and uses a canonical hash of `customSeed` to generate a scrambler.
    - For each segment, it combines the segment with a hash derived from the scrambler.
    - Finally, it processes the last segment of the buffer with the final hash and returns a success code.
- **Output**: Returns `XXH_OK` on successful generation of the secret, or an error code if any input validation fails.
- **Functions called**:
    - [`XXH128_canonicalFromHash`](#XXH128_canonicalFromHash)
    - [`XXH128_hash_t::XXH128`](#XXH128_hash_tXXH128)
    - [`XXH3_combine16`](#XXH3_combine16)
    - [`XXH128_hash_t::XXH128_hashFromCanonical`](#XXH128_hash_tXXH128_hashFromCanonical)
- **See also**: [`XXH_errorcode`](#XXH_errorcode)  (Data Structure)


---
### XXH3\_generateSecret\_fromSeed<!-- {{#callable:XXH3_generateSecret_fromSeed}} -->
Generates a secret key based on a given seed and stores it in a provided buffer.
- **Inputs**:
    - `secretBuffer`: A pointer to the buffer where the generated secret will be stored.
    - `seed`: A 64-bit hash value used to initialize the secret generation.
- **Control Flow**:
    - The function begins by declaring a local array `secret` of size `XXH_SECRET_DEFAULT_SIZE` to hold the generated secret.
    - It calls the `XXH3_initCustomSecret` function, passing the `secret` array and the `seed` to initialize the secret based on the seed value.
    - An assertion is made to ensure that `secretBuffer` is not NULL, which prevents potential dereferencing of a NULL pointer.
    - Finally, the function copies the contents of the `secret` array into the `secretBuffer` using `memcpy`.
- **Output**: The function does not return a value; instead, it populates the `secretBuffer` with the generated secret.


# Function Declarations (Public API)

---
### XXH\_versionNumber<!-- {{#callable_declaration:XXH_versionNumber}} -->
Returns the version number of the XXH library.
- **Description**: Use this function to retrieve the version number of the XXH library currently in use. This can be useful for debugging, logging, or ensuring compatibility with specific features or behaviors of the library. The function does not require any initialization or setup before being called and can be used at any point in the program. It does not modify any state or have any side effects.
- **Inputs**: None
- **Output**: An unsigned integer representing the version number of the XXH library.
- **See also**: [`XXH_versionNumber`](#XXH_versionNumber)  (Implementation)


---
### XXH32\_freeState<!-- {{#callable_declaration:XXH_errorcode::XXH32_freeState}} -->
Frees the memory allocated for an XXH32 state.
- **Description**: Use this function to release the memory associated with an XXH32 state when it is no longer needed. This is important to prevent memory leaks in applications that dynamically allocate hash state structures. The function should be called only on state pointers that were previously allocated using the appropriate XXH32 state allocation function. It is the caller's responsibility to ensure that the pointer is valid and not null before calling this function.
- **Inputs**:
    - `statePtr`: A pointer to an XXH32_state_t structure that was previously allocated. The pointer must not be null, and the caller retains ownership of the memory until it is freed by this function. Passing an invalid or null pointer results in undefined behavior.
- **Output**: Returns XXH_OK to indicate successful deallocation of the state.
- **See also**: [`XXH_errorcode::XXH32_freeState`](#XXH_errorcodeXXH32_freeState)  (Implementation)


---
### XXH32\_copyState<!-- {{#callable_declaration:XXH32_copyState}} -->
Copies the state of an XXH32 hash computation.
- **Description**: Use this function to duplicate the current state of an XXH32 hash computation from one state object to another. This is useful when you need to preserve the current hashing state for later use or to perform parallel computations. The function requires both source and destination state objects to be valid and properly initialized. It does not perform any validation on the state objects themselves, so ensure they are correctly set up before calling this function.
- **Inputs**:
    - `dstState`: A pointer to the destination state object where the source state will be copied. Must not be null and should be a valid, initialized XXH32_state_t object.
    - `srcState`: A pointer to the source state object from which the state will be copied. Must not be null and should be a valid, initialized XXH32_state_t object.
- **Output**: None
- **See also**: [`XXH32_copyState`](#XXH32_copyState)  (Implementation)


---
### XXH32\_reset<!-- {{#callable_declaration:XXH_errorcode::XXH32_reset}} -->
Resets the XXH32 state with a given seed.
- **Description**: This function initializes or resets the state of an XXH32 hashing operation using a specified seed. It must be called before starting a new hashing process with the given state. The function ensures that the state is properly initialized with the seed, preparing it for subsequent data processing. It is essential to provide a valid state pointer, as the function will modify the state in place. The function returns an error code indicating success or failure of the operation.
- **Inputs**:
    - `statePtr`: A pointer to an XXH32_state_t structure that will be reset. Must not be null, as the function will dereference it to initialize the state.
    - `seed`: An XXH32_hash_t value used to initialize the hashing state. This seed can be any 32-bit value and influences the resulting hash.
- **Output**: Returns XXH_OK on successful reset of the state, indicating that the state is ready for use.
- **See also**: [`XXH_errorcode::XXH32_reset`](#XXH_errorcodeXXH32_reset)  (Implementation)


---
### XXH32\_update<!-- {{#callable_declaration:XXH_errorcode::XXH32_update}} -->
Updates the XXH32 hashing state with new input data.
- **Description**: Use this function to feed data into an ongoing XXH32 hash computation. It must be called with a valid state that has been initialized prior to use. The function can handle input data in chunks, allowing for incremental hashing of large data sets. If the input is null, the function expects the length to be zero and will return successfully without modifying the state. This function is designed to be called multiple times with different data segments until all data has been processed.
- **Inputs**:
    - `state`: A pointer to an XXH32_state_t structure that holds the current state of the hash computation. Must not be null and should be properly initialized before calling this function.
    - `input`: A pointer to the data to be hashed. Can be null if len is zero, in which case the function will not modify the state.
    - `len`: The length of the input data in bytes. If input is null, len must be zero.
- **Output**: Returns XXH_OK on success. The state is updated with the new data, and the function can be called repeatedly with additional data.
- **See also**: [`XXH_errorcode::XXH32_update`](#XXH_errorcodeXXH32_update)  (Implementation)


---
### XXH32\_canonicalFromHash<!-- {{#callable_declaration:XXH32_canonicalFromHash}} -->
Converts a 32-bit hash to its canonical form.
- **Description**: This function is used to convert a 32-bit hash value into a canonical form, which is a standardized byte order representation. It is particularly useful when you need to ensure consistent hash values across different platforms with varying endianness. The function must be called with a valid destination pointer where the canonical form will be stored. It is important to ensure that the destination pointer is not null before calling this function.
- **Inputs**:
    - `dst`: A pointer to an XXH32_canonical_t structure where the canonical form of the hash will be stored. Must not be null, and the caller is responsible for allocating this memory.
    - `hash`: A 32-bit hash value of type XXH32_hash_t that is to be converted to canonical form. This value is passed by value and does not have any specific constraints.
- **Output**: None
- **See also**: [`XXH32_canonicalFromHash`](#XXH32_canonicalFromHash)  (Implementation)


---
### XXH64\_freeState<!-- {{#callable_declaration:XXH_errorcode::XXH64_freeState}} -->
Frees the memory allocated for an XXH64 state.
- **Description**: Use this function to release the memory associated with an XXH64 state when it is no longer needed. This function should be called to prevent memory leaks after the state has been initialized and used. It is important to ensure that the state pointer is valid and was previously allocated by the appropriate initialization function. Calling this function with a null pointer is safe and will have no effect.
- **Inputs**:
    - `statePtr`: A pointer to the XXH64 state to be freed. Must be a valid pointer obtained from an XXH64 state initialization function. If null, the function does nothing.
- **Output**: Returns XXH_OK to indicate successful deallocation.
- **See also**: [`XXH_errorcode::XXH64_freeState`](#XXH_errorcodeXXH64_freeState)  (Implementation)


---
### XXH64\_copyState<!-- {{#callable_declaration:XXH64_copyState}} -->
Copies the state of a 64-bit hash computation.
- **Description**: Use this function to duplicate the current state of a 64-bit hash computation from one state object to another. This is useful when you need to preserve the current hashing state for later use or to perform parallel computations based on the same initial state. The function requires both source and destination state objects to be valid and properly initialized. It does not perform any validation on the state objects, so ensure they are correctly set up before calling this function.
- **Inputs**:
    - `dstState`: A pointer to the destination state object where the source state will be copied. Must not be null and should be a valid, initialized XXH64_state_t object.
    - `srcState`: A pointer to the source state object from which the state will be copied. Must not be null and should be a valid, initialized XXH64_state_t object.
- **Output**: None
- **See also**: [`XXH64_copyState`](#XXH64_copyState)  (Implementation)


---
### XXH64\_reset<!-- {{#callable_declaration:XXH_errorcode::XXH64_reset}} -->
Resets the XXH64 state with a given seed.
- **Description**: This function initializes or resets the state of an XXH64 hashing operation using a specified seed. It must be called before starting a new hashing process with the state. The function ensures that the state is properly initialized with the seed, preparing it for subsequent data updates. It is essential to provide a valid state pointer, as the function will modify the state in place. This function does not handle null pointers and expects the caller to ensure the state pointer is valid.
- **Inputs**:
    - `statePtr`: A pointer to an XXH64_state_t structure that will be reset. Must not be null. The caller retains ownership and is responsible for ensuring the pointer is valid.
    - `seed`: A 64-bit hash seed used to initialize the state. It can be any 64-bit value and influences the resulting hash.
- **Output**: Returns XXH_OK on successful reset of the state.
- **See also**: [`XXH_errorcode::XXH64_reset`](#XXH_errorcodeXXH64_reset)  (Implementation)


---
### XXH64\_update<!-- {{#callable_declaration:XXH_errorcode::XXH64_update}} -->
Updates the XXH64 hashing state with new input data.
- **Description**: This function is used to feed data into an ongoing XXH64 hash computation. It should be called with chunks of data to be hashed, and can be called multiple times with different data segments. The function must be called with a valid state that has been initialized prior to use. If the input is NULL, the function expects the length to be zero and will return successfully without modifying the state. This function does not finalize the hash; it only processes the input data.
- **Inputs**:
    - `state`: A pointer to an XXH64_state_t structure that holds the current state of the hash computation. Must not be null and should be properly initialized before calling this function.
    - `input`: A pointer to the data to be hashed. Can be null if len is zero, in which case the function does nothing and returns success.
    - `len`: The length of the input data in bytes. If input is null, len must be zero.
- **Output**: Returns XXH_OK on success, indicating that the state has been updated with the input data.
- **See also**: [`XXH_errorcode::XXH64_update`](#XXH_errorcodeXXH64_update)  (Implementation)


---
### XXH64\_canonicalFromHash<!-- {{#callable_declaration:XXH64_canonicalFromHash}} -->
Converts a 64-bit hash to its canonical form.
- **Description**: This function is used to convert a 64-bit hash value into a canonical form, which is a standardized byte order representation. It is particularly useful when you need to store or transmit hash values in a consistent format across different systems, especially those with varying endianness. The function must be called with a valid destination pointer where the canonical form will be stored. It is important to ensure that the destination pointer is not null and points to a memory area large enough to hold the canonical form.
- **Inputs**:
    - `dst`: A pointer to an XXH64_canonical_t structure where the canonical form of the hash will be stored. Must not be null and must point to a valid memory location.
    - `hash`: The 64-bit hash value to be converted to canonical form. It is a plain integer and does not have any specific constraints.
- **Output**: None
- **See also**: [`XXH64_canonicalFromHash`](#XXH64_canonicalFromHash)  (Implementation)


---
### XXH3\_freeState<!-- {{#callable_declaration:XXH_errorcode::XXH3_freeState}} -->
Frees the memory allocated for an XXH3 state.
- **Description**: Use this function to release the memory associated with an XXH3 state when it is no longer needed. This function should be called to prevent memory leaks after the state has been allocated and used. It is important to ensure that the pointer provided is valid and was previously allocated by the appropriate XXH3 state allocation function. Calling this function with a null pointer is safe and will have no effect.
- **Inputs**:
    - `statePtr`: A pointer to the XXH3 state to be freed. Must be a valid pointer obtained from an XXH3 state allocation function or null. If null, the function does nothing.
- **Output**: Returns XXH_OK to indicate successful deallocation.
- **See also**: [`XXH_errorcode::XXH3_freeState`](#XXH_errorcodeXXH3_freeState)  (Implementation)


---
### XXH3\_copyState<!-- {{#callable_declaration:XXH3_copyState}} -->
Copies the state from a source to a destination state structure.
- **Description**: Use this function to duplicate the state of an existing XXH3_state_t structure into another, allowing you to preserve or manipulate hash states independently. This function is useful when you need to maintain multiple hash states or back up a current state for later use. Ensure that both the source and destination state pointers are valid and properly initialized before calling this function. The function does not perform any validation on the input pointers, so passing null or uninitialized pointers will result in undefined behavior.
- **Inputs**:
    - `dst_state`: A pointer to the destination XXH3_state_t structure where the state will be copied. Must not be null and should be properly initialized by the caller. The caller retains ownership.
    - `src_state`: A pointer to the source XXH3_state_t structure from which the state will be copied. Must not be null and should be properly initialized by the caller. The caller retains ownership.
- **Output**: None
- **See also**: [`XXH3_copyState`](#XXH3_copyState)  (Implementation)


---
### XXH3\_64bits\_reset<!-- {{#callable_declaration:XXH_errorcode::XXH3_64bits_reset}} -->
Resets the state of a 64-bit XXH3 hash computation.
- **Description**: Use this function to reset the state of an ongoing 64-bit XXH3 hash computation, allowing the state to be reused for a new hash calculation. This function must be called with a valid state pointer that has been previously initialized. It is essential to ensure that the state pointer is not null before calling this function, as passing a null pointer will result in an error. This function is typically used when you want to start a new hash computation without reallocating the state structure.
- **Inputs**:
    - `statePtr`: A pointer to an XXH3_state_t structure representing the current state of the hash computation. Must not be null. The caller retains ownership of the state structure.
- **Output**: Returns XXH_OK on success, or XXH_ERROR if the statePtr is null.
- **See also**: [`XXH_errorcode::XXH3_64bits_reset`](#XXH_errorcodeXXH3_64bits_reset)  (Implementation)


---
### XXH3\_64bits\_reset\_withSeed<!-- {{#callable_declaration:XXH_errorcode::XXH3_64bits_reset_withSeed}} -->
Resets the XXH3 64-bit hashing state with a specified seed.
- **Description**: This function resets the state of an XXH3 64-bit hash computation using a specified seed, allowing for the initialization or re-initialization of the hashing process with a custom seed value. It must be called before starting a new hash computation with the given state. If the seed is zero, it defaults to a standard reset without a custom seed. The function ensures that the state is properly initialized for subsequent hashing operations.
- **Inputs**:
    - `statePtr`: A pointer to an XXH3_state_t structure representing the hashing state. Must not be null. The caller retains ownership and is responsible for ensuring the state is valid and properly allocated.
    - `seed`: A 64-bit hash seed used to initialize the hashing state. If zero, the function performs a standard reset without a custom seed. Non-zero seeds allow for custom hash initialization.
- **Output**: Returns XXH_OK on successful reset, or XXH_ERROR if the statePtr is null.
- **See also**: [`XXH_errorcode::XXH3_64bits_reset_withSeed`](#XXH_errorcodeXXH3_64bits_reset_withSeed)  (Implementation)


---
### XXH3\_64bits\_reset\_withSecret<!-- {{#callable_declaration:XXH_errorcode::XXH3_64bits_reset_withSecret}} -->
Resets the XXH3 64-bit hashing state with a custom secret.
- **Description**: This function prepares the XXH3 64-bit hashing state for a new hashing operation using a user-provided secret. It must be called before starting a new hash computation with a custom secret. The function ensures that the state is properly initialized with the given secret, which must meet the minimum size requirement. If the state pointer is null, or if the secret is null or too small, the function returns an error code.
- **Inputs**:
    - `statePtr`: A pointer to the XXH3 hashing state to be reset. Must not be null. The caller retains ownership and is responsible for managing the memory of the state.
    - `secret`: A pointer to the custom secret used for hashing. Must not be null. The secret is used to initialize the hashing state and must be at least XXH3_SECRET_SIZE_MIN bytes in size.
    - `secretSize`: The size of the secret in bytes. Must be greater than or equal to XXH3_SECRET_SIZE_MIN. If the size is less than this minimum, the function returns an error.
- **Output**: Returns XXH_OK on success, or XXH_ERROR if the state pointer is null, the secret is null, or the secret size is insufficient.
- **See also**: [`XXH_errorcode::XXH3_64bits_reset_withSecret`](#XXH_errorcodeXXH3_64bits_reset_withSecret)  (Implementation)


---
### XXH3\_64bits\_update<!-- {{#callable_declaration:XXH_errorcode::XXH3_64bits_update}} -->
Updates the XXH3 64-bit hash state with new input data.
- **Description**: This function is used to incorporate additional data into an ongoing XXH3 64-bit hash computation. It must be called after initializing the hash state and before finalizing the hash. The function processes the input data and updates the internal state accordingly. It is designed to handle input data of any length, including zero-length inputs, without causing errors. The function is part of a streaming hash API, allowing for incremental hashing of data as it becomes available.
- **Inputs**:
    - `state`: A pointer to an initialized XXH3_state_t structure representing the current hash state. Must not be null. The caller retains ownership and is responsible for managing the lifecycle of the state.
    - `input`: A pointer to the data to be hashed. Can be null if len is zero. The caller retains ownership of the data.
    - `len`: The length of the input data in bytes. Can be zero, in which case the function does nothing.
- **Output**: Returns an XXH_errorcode indicating success or failure of the update operation. A non-zero return value indicates an error.
- **See also**: [`XXH_errorcode::XXH3_64bits_update`](#XXH_errorcodeXXH3_64bits_update)  (Implementation)


---
### XXH3\_128bits\_reset<!-- {{#callable_declaration:XXH_errorcode::XXH3_128bits_reset}} -->
Resets the state of a 128-bit hash computation.
- **Description**: Use this function to reset the state of an ongoing 128-bit hash computation, allowing the state to be reused for a new hash calculation. This function must be called before starting a new hash computation with the same state object. It is essential to ensure that the state pointer is valid and properly initialized before calling this function. This function does not allocate or deallocate memory, and it does not handle null pointers, so the caller must ensure the state pointer is not null.
- **Inputs**:
    - `statePtr`: A pointer to an XXH3_state_t structure representing the state of the hash computation. Must not be null. The caller retains ownership and is responsible for ensuring the state is properly initialized before calling this function.
- **Output**: Returns an XXH_errorcode indicating success or failure of the reset operation.
- **See also**: [`XXH_errorcode::XXH3_128bits_reset`](#XXH_errorcodeXXH3_128bits_reset)  (Implementation)


---
### XXH3\_128bits\_reset\_withSeed<!-- {{#callable_declaration:XXH_errorcode::XXH3_128bits_reset_withSeed}} -->
Resets the XXH3 128-bit hashing state with a seed.
- **Description**: This function prepares the XXH3 128-bit hashing state for a new hashing operation by resetting it and applying a specified seed. It should be called before starting a new hash computation with a seeded state. The function is useful when you need to compute a hash with a specific seed value, which can help in generating different hash results for the same input data. Ensure that the state pointer provided is valid and properly initialized before calling this function.
- **Inputs**:
    - `statePtr`: A pointer to an XXH3_state_t structure that represents the hashing state. Must not be null and should be properly initialized before use. The caller retains ownership of the state.
    - `seed`: A 64-bit hash value used to seed the hashing state. This value can be any 64-bit integer and is used to influence the resulting hash.
- **Output**: Returns an XXH_errorcode indicating success or failure of the operation. A successful reset will return XXH_OK.
- **See also**: [`XXH_errorcode::XXH3_128bits_reset_withSeed`](#XXH_errorcodeXXH3_128bits_reset_withSeed)  (Implementation)


---
### XXH3\_128bits\_reset\_withSecret<!-- {{#callable_declaration:XXH_errorcode::XXH3_128bits_reset_withSecret}} -->
Resets the XXH3 128-bit hashing state with a custom secret.
- **Description**: This function is used to reset the state of an XXH3 128-bit hash computation, allowing the use of a custom secret for the hashing process. It is typically called when you want to start a new hash computation with a specific secret key, which can enhance the security of the hash. The function must be called before any data is fed into the hash state. The secret provided must be valid and of an appropriate size, as the function will not perform the hash correctly with an invalid secret.
- **Inputs**:
    - `statePtr`: A pointer to an XXH3_state_t structure that holds the state of the hash computation. Must not be null, and should point to a properly initialized state structure.
    - `secret`: A pointer to a buffer containing the custom secret key. Must not be null, and the buffer should contain at least 'secretSize' bytes.
    - `secretSize`: The size of the secret in bytes. Must be a valid size for the secret to be used effectively in the hash computation.
- **Output**: Returns an XXH_errorcode indicating success or failure of the operation. A non-zero value indicates an error.
- **See also**: [`XXH_errorcode::XXH3_128bits_reset_withSecret`](#XXH_errorcodeXXH3_128bits_reset_withSecret)  (Implementation)


---
### XXH3\_128bits\_update<!-- {{#callable_declaration:XXH_errorcode::XXH3_128bits_update}} -->
Updates the XXH3 128-bit hash state with new input data.
- **Description**: Use this function to incorporate additional data into an ongoing XXH3 128-bit hash computation. It must be called after initializing the hash state and before finalizing the hash. This function allows for incremental hashing of data, which is useful for processing large datasets or streaming data. Ensure that the state has been properly initialized and is not null before calling this function. The input data can be of any length, including zero, and the function can be called multiple times with different data chunks to update the hash state incrementally.
- **Inputs**:
    - `state`: A pointer to an initialized XXH3_state_t structure representing the current state of the hash computation. Must not be null. The caller retains ownership and is responsible for managing the lifecycle of this state.
    - `input`: A pointer to the data to be hashed. Can be null if len is zero. The caller retains ownership of the data.
    - `len`: The length of the input data in bytes. Can be zero, in which case the input pointer can be null.
- **Output**: Returns an XXH_errorcode indicating success or failure of the update operation. A non-zero return value indicates an error.
- **See also**: [`XXH_errorcode::XXH3_128bits_update`](#XXH_errorcodeXXH3_128bits_update)  (Implementation)


---
### XXH128\_isEqual<!-- {{#callable_declaration:XXH128_isEqual}} -->
Compares two 128-bit hash values for equality.
- **Description**: Use this function to determine if two 128-bit hash values are identical. It is useful in scenarios where you need to verify that two data sets produce the same hash result. The function expects two hash values as input and returns an integer indicating whether they are equal. This function is typically used in hashing applications where 128-bit hashes are employed, and it assumes that the input hash values are valid and properly initialized.
- **Inputs**:
    - `h1`: The first 128-bit hash value to compare. It must be a valid XXH128_hash_t type and properly initialized.
    - `h2`: The second 128-bit hash value to compare. It must also be a valid XXH128_hash_t type and properly initialized.
- **Output**: Returns 1 if the hash values are equal, and 0 if they are not.
- **See also**: [`XXH128_isEqual`](#XXH128_isEqual)  (Implementation)


---
### XXH128\_cmp<!-- {{#callable_declaration:XXH128_cmp}} -->
Compares two 128-bit hash values.
- **Description**: Use this function to compare two 128-bit hash values, typically to determine their relative order or equality. It is useful in scenarios where hash values are used as keys or identifiers, and a consistent ordering is required. The function expects valid pointers to two 128-bit hash values and returns an integer indicating their comparison result. Ensure that the pointers provided are not null and point to valid 128-bit hash data.
- **Inputs**:
    - `h128_1`: A pointer to the first 128-bit hash value to compare. Must not be null and must point to a valid 128-bit hash.
    - `h128_2`: A pointer to the second 128-bit hash value to compare. Must not be null and must point to a valid 128-bit hash.
- **Output**: Returns a positive integer if the first hash is greater, a negative integer if the second hash is greater, and zero if they are equal.
- **See also**: [`XXH128_cmp`](#XXH128_cmp)  (Implementation)


---
### XXH128\_canonicalFromHash<!-- {{#callable_declaration:XXH128_canonicalFromHash}} -->
Converts a 128-bit hash to its canonical form.
- **Description**: This function is used to convert a 128-bit hash value into a canonical form, which is a standardized byte order representation. It is particularly useful when you need to ensure consistent hash representation across different systems, especially those with varying endianness. The function must be called with a valid destination pointer where the canonical form will be stored. It is important to ensure that the destination pointer is not null and points to a memory area large enough to hold the canonical form. The function does not return a value, and the canonical form is written directly to the memory location pointed to by the destination pointer.
- **Inputs**:
    - `dst`: A pointer to an XXH128_canonical_t structure where the canonical form of the hash will be stored. Must not be null and must point to a valid memory location large enough to hold the canonical form.
    - `hash`: The 128-bit hash value to be converted to canonical form. It is passed by value and is not modified by the function.
- **Output**: None
- **See also**: [`XXH128_canonicalFromHash`](#XXH128_canonicalFromHash)  (Implementation)


---
### XXH3\_generateSecret<!-- {{#callable_declaration:XXH_errorcode::XXH3_generateSecret}} -->
Generates a secret buffer using a custom seed.
- **Description**: This function is used to fill a buffer with a secret derived from a custom seed, which can be used for hashing purposes. It must be called with a valid buffer and a size that meets the minimum secret size requirement. If the custom seed size is zero, a default secret is used. The function ensures that the buffer is filled by repeating the seed as necessary and then scrambles the buffer content for added security. It returns an error code if any input validation fails.
- **Inputs**:
    - `secretBuffer`: A pointer to the buffer where the generated secret will be stored. Must not be null, and the caller retains ownership.
    - `secretSize`: The size of the secretBuffer in bytes. Must be at least XXH3_SECRET_SIZE_MIN.
    - `customSeed`: A pointer to the custom seed used to generate the secret. If customSeedSize is zero, a default seed is used. Must not be null if customSeedSize is non-zero.
    - `customSeedSize`: The size of the customSeed in bytes. If zero, a default seed is used.
- **Output**: Returns XXH_OK on success or XXH_ERROR if any input validation fails.
- **See also**: [`XXH_errorcode::XXH3_generateSecret`](#XXH_errorcodeXXH3_generateSecret)  (Implementation)


---
### XXH3\_generateSecret\_fromSeed<!-- {{#callable_declaration:XXH3_generateSecret_fromSeed}} -->
Generates a secret using a seed and stores it in a buffer.
- **Description**: This function is used to generate a secret based on a given seed and store it in a provided buffer. It is typically used when a custom secret is needed for hashing operations. The function must be called with a valid buffer that is large enough to hold the secret, and it is the caller's responsibility to ensure that the buffer is not null. The seed is used to initialize the secret, allowing for reproducible secret generation.
- **Inputs**:
    - `secretBuffer`: A pointer to a buffer where the generated secret will be stored. Must not be null and must be large enough to hold the secret.
    - `seed`: A 64-bit hash value used to generate the secret. It determines the content of the generated secret, allowing for reproducibility.
- **Output**: None
- **See also**: [`XXH3_generateSecret_fromSeed`](#XXH3_generateSecret_fromSeed)  (Implementation)


---
### XXH3\_64bits\_reset\_withSecretandSeed<!-- {{#callable_declaration:XXH_errorcode::XXH3_64bits_reset_withSecretandSeed}} -->
Resets the XXH3 state with a secret and seed for 64-bit hashing.
- **Description**: This function prepares the XXH3 state for a new hashing operation using a specified secret and seed. It must be called before starting a new hash computation with the given state. The function requires a valid state pointer, a non-null secret, and a secret size that meets the minimum requirement. It is essential for users to ensure these preconditions are met to avoid errors. The function modifies the state to incorporate the seed, even if the seed is zero.
- **Inputs**:
    - `statePtr`: A pointer to an XXH3_state_t structure that will be reset. Must not be null. The caller retains ownership.
    - `secret`: A pointer to a secret key used for hashing. Must not be null. The caller retains ownership.
    - `secretSize`: The size of the secret in bytes. Must be at least XXH3_SECRET_SIZE_MIN. If less, the function returns an error.
    - `seed64`: A 64-bit seed value used to influence the hash result. Can be zero.
- **Output**: Returns XXH_OK on success or XXH_ERROR if any input is invalid.
- **See also**: [`XXH_errorcode::XXH3_64bits_reset_withSecretandSeed`](#XXH_errorcodeXXH3_64bits_reset_withSecretandSeed)  (Implementation)


---
### XXH3\_128bits\_reset\_withSecretandSeed<!-- {{#callable_declaration:XXH_errorcode::XXH3_128bits_reset_withSecretandSeed}} -->
Resets the XXH3 128-bit hashing state with a secret and seed.
- **Description**: This function prepares the XXH3 128-bit hashing state for a new hashing operation by resetting it with a specified secret and seed. It is essential to call this function before starting a new hash computation if a secret and seed are to be used. The function ensures that the hashing state is correctly initialized with the provided parameters, which can enhance security and variability of the hash results. The secret must be a valid memory block of at least the specified size, and the seed is used to further randomize the hash output. This function must be called before any data is fed into the hashing state.
- **Inputs**:
    - `statePtr`: A pointer to an XXH3_state_t structure that holds the hashing state. Must not be null, and the caller retains ownership.
    - `secret`: A pointer to a memory block containing the secret used for hashing. Must not be null, and the memory block should be at least 'secretSize' bytes long.
    - `secretSize`: The size of the secret in bytes. Must be a valid size that the implementation can handle.
    - `seed`: A 64-bit value used to seed the hash function, providing additional randomness.
- **Output**: Returns an XXH_errorcode indicating success or failure of the operation.
- **See also**: [`XXH_errorcode::XXH3_128bits_reset_withSecretandSeed`](#XXH_errorcodeXXH3_128bits_reset_withSecretandSeed)  (Implementation)


---
### XXH3\_scalarRound<!-- {{#callable_declaration:XXH3_scalarRound}} -->
Performs a scalar round operation on the accumulator using input and secret data.
- **Description**: This function is used to update an accumulator with a scalar round operation, which involves reading and processing data from the input and secret buffers. It is typically used in hashing or cryptographic operations where such transformations are necessary. The function requires that the lane index is within a valid range and that the accumulator is properly aligned. It is important to ensure that the input and secret buffers are valid and that the lane index does not exceed the number of available lanes.
- **Inputs**:
    - `acc`: A pointer to the accumulator buffer, which must be aligned according to XXH_ACC_ALIGN. The caller retains ownership and must ensure it is not null.
    - `input`: A pointer to the input buffer containing data to be processed. The caller retains ownership and must ensure it is not null.
    - `secret`: A pointer to the secret buffer used in the transformation. The caller retains ownership and must ensure it is not null.
    - `lane`: An index specifying which lane of the accumulator to update. It must be less than XXH_ACC_NB, otherwise the behavior is undefined.
- **Output**: None
- **See also**: [`XXH3_scalarRound`](#XXH3_scalarRound)  (Implementation)


---
### XXH3\_scalarScrambleRound<!-- {{#callable_declaration:XXH3_scalarScrambleRound}} -->
Scrambles a specific lane of the accumulator using a secret key.
- **Description**: This function is used to modify a specific lane of an accumulator by scrambling it with a secret key. It is typically used in hashing algorithms where such scrambling is necessary to ensure data integrity and security. The function requires that the accumulator is aligned to a specific boundary, and the lane index must be within a valid range. It is important to ensure that the accumulator and secret pointers are not null and that the lane index is within the expected bounds to avoid undefined behavior.
- **Inputs**:
    - `acc`: A pointer to the accumulator array, which must be aligned to the boundary defined by XXH_ACC_ALIGN. The caller retains ownership and it must not be null.
    - `secret`: A pointer to the secret key data, which does not have any specific alignment requirements. The caller retains ownership and it must not be null.
    - `lane`: The index of the lane within the accumulator to be scrambled. It must be less than XXH_ACC_NB, otherwise the behavior is undefined.
- **Output**: None
- **See also**: [`XXH3_scalarScrambleRound`](#XXH3_scalarScrambleRound)  (Implementation)


